%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{hdlregression}
\date{Oct 11, 2024}
\release{0.58.0
}
\author{UVVM}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}

\section{What is HDLRegression}
\label{\detokenize{intro:what-is-hdlregression}}
\sphinxAtStartPar
HDLRegression is a fully customizable regression tool written in Python for running HDL testbenches, and have a
very low user threshold for getting started with, but can also be used in very advanced projects.
Setting up a test regression script is straight forward and requires little Python knowledge.

\sphinxAtStartPar
For an existing project to start using HDLRegression there are only two tasks that have to be carried out
\begin{itemize}
\item {} 
\sphinxAtStartPar
1 \sphinxhyphen{} add a code comment to the top level testbench entity

\item {} 
\sphinxAtStartPar
2 \sphinxhyphen{} make a test script where libraries and files are specified.

\end{itemize}

\sphinxAtStartPar
HDLRegression is shipped with basic and advanced test script {\hyperref[\detokenize{templates::doc}]{\sphinxcrossref{\DUrole{doc}{Template files}}}} files that have guidelines instructions that help the
test designer in getting started in setting up a complete and ready to use HDLRegression test script.
The basic template file show the only code that is required to run HDLRegression, where all that is needed is to add file(s)
and potentially a compile library.

\sphinxAtStartPar
HDLRegression is distributed as open source and can be downloaded from \sphinxhref{https://github.com/UVVM}{GitHub}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
HDLRegression is not a verification framework but a tool for running testbenches that verifies the design behaviour.

\sphinxAtStartPar
This allows you to choose any verification framework, e.g. company internal developed, UVVM, OSVVM, VUnit and so on.
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Without making any changes to the verification files other than adding a single code comment in the testbench.

\item {} 
\sphinxAtStartPar
Without the need for regression dedicated VHDL code from other frameworks \sphinxhyphen{} use whichever you prefer.

\item {} 
\sphinxAtStartPar
With a verification framework independent regression suite.

\end{enumerate}
\end{sphinxadmonition}


\section{What is regression testing}
\label{\detokenize{intro:what-is-regression-testing}}\label{\detokenize{intro:regression-testing}}
\sphinxAtStartPar
Regression testing is re\sphinxhyphen{}running functional and non\sphinxhyphen{}functional tests to ensure that previously developed and
tested software still performs after a change. (\sphinxhref{https://en.wikipedia.org/wiki/Regression\_testing}{wikipedia})


\section{Terminology}
\label{\detokenize{intro:terminology}}

\subsection{Testbench}
\label{\detokenize{intro:testbench}}
\sphinxAtStartPar
A testbench is the top level entity and architecture which is used as input to the simulations.
Verification of a DUT (device under test) may require one or more testbenches. The testbench will
consist of:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A test sequencer.

\item {} 
\sphinxAtStartPar
A test\sphinxhyphen{}harness \sphinxhyphen{} not required, but recommended.

\item {} 
\sphinxAtStartPar
Optionally other support modules, procedures or statements outside the test\sphinxhyphen{}harness.

\end{itemize}

\sphinxAtStartPar
Different configurations of a testbench using different DUT architectures are considered as the same
testbench, running on different DUT representations.
Different configurations of a testbench using different test\sphinxhyphen{}harness architectures are considered as
different testbenches, as testbench behaviour may be different.


\subsection{Test sequencer}
\label{\detokenize{intro:test-sequencer}}
\sphinxAtStartPar
The test sequencer is a single VHDL process controlling the simulations from start to end, and may sometimes
be called the “central (test) sequencer”.


\subsection{Test\sphinxhyphen{}harness}
\label{\detokenize{intro:test-harness}}
\sphinxAtStartPar
The test\sphinxhyphen{}harness consist of a VHDL entity containing the fixed parts of the verification environment \sphinxhyphen{} often shared
between various testbenches. E.g. DUT and verification support such as verification components or processes,
including concurrent procedures.


\subsection{Test suite}
\label{\detokenize{intro:test-suite}}
\sphinxAtStartPar
A test suite is the complete set of testbenches required for a given DUT, or for a complete FPGA including modules.


\subsection{Testcase}
\label{\detokenize{intro:testcase}}
\sphinxAtStartPar
A testcase is
\begin{itemize}
\item {} 
\sphinxAtStartPar
A scenario or sequence of actions that are controlled by the test sequencer.

\item {} 
\sphinxAtStartPar
May test one or multiple features/requirements.

\item {} 
\sphinxAtStartPar
Typically testing of related functionality, or a logical sequence of events, or an efficient sequence
of events.

\item {} 
\sphinxAtStartPar
The minimum sequence of events possible to run in a single simulation execution. Thus, if there is an option to
run of multiple test sequences (A, B or C), a set of test sequences (A and B) or all sequences (A+B+C), then all
of A, B and C are defined as individual testcases.

\end{itemize}


\subsection{Test group}
\label{\detokenize{intro:test-group}}
\sphinxAtStartPar
A test group is a collection of testcases that typically verifies the same modules or features of a DUT.
There are several ways of structuring testbenches and testcases, and HDLRegression support many of these.

\sphinxAtStartPar
A test group can be:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A single testbench or a collection of testbenches

\item {} 
\sphinxAtStartPar
A single testcase or a collection of testcases

\end{itemize}

\sphinxAtStartPar
Typically a test group contains testbenches and/or testcases that verifies a set of features or functionality,
e.g. error injection, interface functionality or any other sub\sphinxhyphen{}set of DUT functionality.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{test_group}.png}\hspace*{\fill}}


\chapter{Usage}
\label{\detokenize{intro:usage}}
\sphinxAtStartPar
HDLRegression is configured using a Python 3 script that imports the HDLRegression module which is used for creating a HDLRegression
object which is used to customize the regression run using a set of {\hyperref[\detokenize{api::doc}]{\sphinxcrossref{\DUrole{doc}{Application Programming Interface (API)}}}} commands.

\sphinxAtStartPar
When HDLRegression is run it will perform several tasks in the background, and if any of the files added is a {\hyperref[\detokenize{intro:testbench}]{\sphinxcrossref{testbench}}} file,
i.e. with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}HDLREGRESSION:TB}} \sphinxstyleemphasis{(VHDL)} or \sphinxcode{\sphinxupquote{//HDLREGRESSION:TB}} \sphinxstyleemphasis{(Verilog)} pragma set, HDLRegression will:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Organize files and libraries by dependencies

\item {} 
\sphinxAtStartPar
Scan for defined testcases in the testbench (a testcase generic is required for this feature)

\item {} 
\sphinxAtStartPar
Compile to the default or a specified library

\item {} 
\sphinxAtStartPar
Run all testbenches

\item {} 
\sphinxAtStartPar
Report simulation results to terminal

\end{itemize}


\chapter{Installation}
\label{\detokenize{intro:installation}}
\sphinxAtStartPar
For the regression script to be able to use the HDLRegression package module,
one has to do one of the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Install HDLRegression using the {\hyperref[\detokenize{intro:setup-py}]{\sphinxcrossref{setup.py}}} script.

\item {} 
\sphinxAtStartPar
Add the HDLRegression install path to {\hyperref[\detokenize{intro:python-path}]{\sphinxcrossref{Python PATH}}} inside the regression script.

\end{itemize}


\section{Setup script}
\label{\detokenize{intro:setup-script}}\label{\detokenize{intro:setup-py}}
\sphinxAtStartPar
There is a setup.py script in the HDLRegression root folder that can be used for installing HDLRegression as a
Python package, and installing HDLRegression will make it importable without adding it to the Python PATH.
We recommend that HDLRegression is installed as a Python package as this will make the regression script more
portable and easy to write.
Execute the two following commands to install HDLRegression as package:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Build the package

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python3 setup.py build}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Install the HDLRegression package

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python3 setup.py develop}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or use the Python package\sphinxhyphen{}management system

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip install .}
\end{sphinxVerbatim}

\sphinxAtStartPar
HDLRegression can be imported directly in the regression script as any standard Python module

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}
\end{sphinxVerbatim}


\subsection{Uninstall}
\label{\detokenize{intro:uninstall}}
\sphinxAtStartPar
Uninstalling can be done with the commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python3 setup.py develop \PYGZhy{}\PYGZhy{}uninstall}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or if installed using pip:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip uninstall hdlregression}
\end{sphinxVerbatim}


\section{Python PATH}
\label{\detokenize{intro:python-path}}
\sphinxAtStartPar
The HDLRegression module can be used without package installation by adding the HDLRegression install path to the
Python PATH variable at the beginning of the regression script:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{path\PYGZus{}to\PYGZus{}hdlregression\PYGZus{}folder}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
HDLRegression will have to be added to the Python PATH in every regression script which will make
the regression script less portable.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Relative paths will be relative to the regression script
and not where the regression script is called from.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Application Programming Interface (API)}
\label{\detokenize{api:application-programming-interface-api}}\label{\detokenize{api::doc}}
\sphinxAtStartPar
HDLRegression is configured and run using a Python script that imports the HDLRegression module and
uses a set of API methods. Because HDLRegression is written in Python the test designer can
utilize the full Python API and modules to make advanced regression scripts.
There are two template script files in the \sphinxcode{\sphinxupquote{%
/template%
}} folder to help new users get started.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER HDLRegression PATH \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} If HDLRegression is not installed as a Python package (see doc)}
\PYG{c+c1}{\PYGZsh{} then uncomment the following line and set the path for}
\PYG{c+c1}{\PYGZsh{} the HDLRegression install folder :}
\PYG{c+c1}{\PYGZsh{}sys.path.append(\PYGZlt{}full\PYGZus{}or\PYGZus{}relative\PYGZus{}path\PYGZus{}to\PYGZus{}hdlregression\PYGZus{}install\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Import the HDLRegression module to the Python script:}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}

\PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
\PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{})                   \PYGZsh{} Use default library my\PYGZus{}work\PYGZus{}lib}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{}, \PYGZlt{}library\PYGZus{}name\PYGZgt{})   \PYGZsh{} or specify a library name.}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{HDLRegression()}
\label{\detokenize{api:hdlregression}}
\sphinxAtStartPar
This command is used for initializing the HDLRegression object which is used for defining the regression script
and accessing the HDLRegression API.

\sphinxAtStartPar
HDLRegression will attempt to auto\sphinxhyphen{}detect available simulators and will choose either ModelSim, NVC, GHDL, or
Riviera Pro based on the findings. The preffered simulator can be selected by using the \sphinxcode{\sphinxupquote{simulator}} argument as shown
in example 2 or using {\hyperref[\detokenize{cli::doc}]{\sphinxcrossref{\DUrole{doc}{Command Line Interface (CLI)}}}} :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HDLRegression}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{simulator}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
simulator
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
“ghdl”, “modelsim”, “nvc”
&
\sphinxAtStartPar
auto\sphinxhyphen{}detected
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
arg\_parser
&
\sphinxAtStartPar
argparser obj
&
\sphinxAtStartPar
regression\_parser
&
\sphinxAtStartPar
None
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
output\_path
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
“hdlreg\_output”
&
\sphinxAtStartPar
None
&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example 1:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.} \PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

\PYG{l+m+mf}{2.} \PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{n}{simulator}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ghdl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
An argparser object can be created in the regression script and passed on to the HDLRegression() object creation to allow
for having local argument parsing in the regression script. When an argparser object is passed on to HDLRegression it will
add all its arguments to the argparser object. The parsed arguments can be collected using the {\hyperref[\detokenize{api:get-args}]{\sphinxcrossref{get\_args()}}} method as show
in example 2.

\sphinxAtStartPar
\sphinxstylestrong{Example 2:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{argparse}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}

\PYG{n}{arg\PYGZus{}parser} \PYG{o}{=} \PYG{n}{argparse}\PYG{o}{.}\PYG{n}{ArgumentParser}\PYG{p}{(}\PYG{n}{description}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Regression script parser}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{arg\PYGZus{}parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}rtl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{action}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{store\PYGZus{}true}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{run RTL simulations}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{arg\PYGZus{}parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}netlist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{action}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{store\PYGZus{}true}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{run netlist simulations}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{n}{arg\PYGZus{}parser}\PYG{o}{=}\PYG{n}{arg\PYGZus{}parser}\PYG{p}{)}

\PYG{n}{args} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}args}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{rtl}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} add rtl files}
  \PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{netlist}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} add netlist files}
  \PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Basic methods}
\label{\detokenize{api:basic-methods}}

\subsection{add\_files()}
\label{\detokenize{api:add-files}}
\begin{DUlineblock}{0em}
\item[] Specifies a single or set of files that will be associated with a library name.
\item[] The library name can be selected explicitly using the \sphinxcode{\sphinxupquote{library\_name}} argument or by first setting a library name
using the {\hyperref[\detokenize{api:set-library}]{\sphinxcrossref{set\_library()}}} method and then omitting the \sphinxcode{\sphinxupquote{library\_name}} argument from the \sphinxcode{\sphinxupquote{add\_files()}} method.
See example 2 and 3 below for different approaches to setting library names.
\item[] For VHDL, the files are compiled to the \sphinxcode{\sphinxupquote{library\_name}} library, thus the \sphinxcode{\sphinxupquote{library\_name}} will need to correspond
with the library name used in the design or test environment files.
\end{DUlineblock}

\sphinxAtStartPar
Files can be referenced with the relative and absolute paths, and the {\hyperref[\detokenize{api:add-files}]{\sphinxcrossref{add\_files()}}} method
can be called several times in the regressions script, addressing the same or a different library name.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{filename}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{library\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{hdl\PYGZus{}version}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{com\PYGZus{}options}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{netlist\PYGZus{}inst}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{code\PYGZus{}coverage}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{filename}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
filename
&
\sphinxAtStartPar
string
&&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
library\_name
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
“my\_work\_lib”
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
hdl\_version
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
2008
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
com\_options
&
\sphinxAtStartPar
string
&&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
parse\_file
&
\sphinxAtStartPar
boolean
&
\sphinxAtStartPar
True
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
netlist\_inst
&
\sphinxAtStartPar
string
&&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
code\_coverage
&
\sphinxAtStartPar
boolean
&&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example 1:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../src/my\PYGZus{}testbench.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}testbench\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{hdl\PYGZus{}version}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2008}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../backend/my\PYGZus{}design.sdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}design\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{hdl\PYGZus{}version}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2008}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{netlist\PYGZus{}inst}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/my\PYGZus{}testnech/i\PYGZus{}test\PYGZus{}harness/i\PYGZus{}dut}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{code\PYGZus{}coverage}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example 2: with library name}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/tools/uvvm/uvvm\PYGZus{}util/src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{library\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uvvm\PYGZus{}util}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/project/design/src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{library\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{design\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/project/design/src/ip/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{library\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{design\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/project/design/tb/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{library\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example 3: with set\_library()}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}library}\PYG{p}{(}\PYG{n}{library\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{uvvm\PYGZus{}util}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/tools/uvvm/uvvm\PYGZus{}util/src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}library}\PYG{p}{(}\PYG{n}{library\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{design\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/project/design/src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/project/design/ip/src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}library}\PYG{p}{(}\PYG{n}{library\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/project/design/tb/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Relative paths will be relative to the regression script
and not where the regression script is called from.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A back annotated timing file (SDF) require the \sphinxcode{\sphinxupquote{netlist\_inst}} arguments and a back annotated timing file (VHD)
require the \sphinxcode{\sphinxupquote{parse\_file}} argument set to \sphinxcode{\sphinxupquote{True}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{netlist\_inst}} argument is a string that has to be set to design instantiation path in the design.

\item {} 
\sphinxAtStartPar
Any number of back\sphinxhyphen{}annotated timing files can be added.

\end{enumerate}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{code\_coverage}} argument enables code coverage for a single file if an explicit filename is given, or
a set of files when used with wildcards in the filename.

\sphinxAtStartPar
It is required that the {\hyperref[\detokenize{api:set-code-coverage}]{\sphinxcrossref{set\_code\_coverage()}}} method is used to set the code coverage settings.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{parse\_file}} is set to \sphinxcode{\sphinxupquote{False}} HDLRregression will not parse the file content, not include the file in the
compilation order and not compile the file.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Use wildcards to more effectively filter searches, i.e. testcases and filenames.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Pattern
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
*
&
\sphinxAtStartPar
match all
\\
\sphinxhline
\sphinxAtStartPar
?
&
\sphinxAtStartPar
match a single charecter
\\
\sphinxhline
\sphinxAtStartPar
{[}seq{]}
&
\sphinxAtStartPar
match any character in seq
\\
\sphinxhline
\sphinxAtStartPar
{[}!seq{]}
&
\sphinxAtStartPar
match all character not in seq
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{set\_library()}
\label{\detokenize{api:set-library}}
\sphinxAtStartPar
Changes the default library name used when {\hyperref[\detokenize{api:add-files}]{\sphinxcrossref{add\_files()}}} is used without the \sphinxcode{\sphinxupquote{library\_name}} argument.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set\PYGZus{}default\PYGZus{}library}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{library\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
library\_name
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}library}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testbench\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The default library name is \sphinxstyleemphasis{“my\_work\_lib”}.
\end{sphinxadmonition}


\subsection{start()}
\label{\detokenize{api:start}}
\begin{DUlineblock}{0em}
\item[] This method will initiate compilation, simulation, reporting etc.
\item[] After calling this method, adding files or making changes to simulation configurations in the regression script
\item[] is not permitted. Ensure that all necessary files and configurations are set before invoking the method to avoid
\item[] issues during the simulation process.
\end{DUlineblock}

\sphinxAtStartPar
\sphinxstylestrong{Return code}

\sphinxAtStartPar
The return code from the start() method is either 0 or 1, based on whether the success criteria listed below are met:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Criteria
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Return code
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
No compilation error and testcase(s) has been run without errors
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
No compilation error and no testcase run
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
No compilation error and testcase run with one or more errors
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
Compilation error (no testcases will be run)
&
\sphinxAtStartPar
1
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Arguments}

\sphinxAtStartPar
The default operation is to run in {\hyperref[\detokenize{intro:what-is-regression-testing}]{\sphinxcrossref{\DUrole{std,std-ref}{regression mode}}}} without {\hyperref[\detokenize{gui::doc}]{\sphinxcrossref{\DUrole{doc}{GUI}}}} enabled,
yet this can be changed using the available arguments or by using the {\hyperref[\detokenize{cli::doc}]{\sphinxcrossref{\DUrole{doc}{command line interfaces}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{start}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{gui\PYGZus{}mode}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{stop\PYGZus{}on\PYGZus{}failure}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{regression\PYGZus{}mode}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{threading}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{sim\PYGZus{}options}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{netlist\PYGZus{}timing}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{com\PYGZus{}options}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Options \& Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
gui\_mode
&
\sphinxAtStartPar
True/False (boolean)
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
GUI mode control
\\
\sphinxhline
\sphinxAtStartPar
regression\_mode
&
\sphinxAtStartPar
True/False (boolean)
&
\sphinxAtStartPar
True
&
\sphinxAtStartPar
Regression mode control
\\
\sphinxhline
\sphinxAtStartPar
stop\_on\_failure
&
\sphinxAtStartPar
True/False (boolean)
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
Stop on first failure
\\
\sphinxhline
\sphinxAtStartPar
threading
&
\sphinxAtStartPar
True/False (boolean)
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
Enable threading
\\
\sphinxhline
\sphinxAtStartPar
com\_options
&
\sphinxAtStartPar
string/list of string
&
\sphinxAtStartPar
{\hyperref[\detokenize{api:table1}]{\sphinxcrossref{\DUrole{std,std-ref}{See table 1}}}}
&
\sphinxAtStartPar
Compilation options
\\
\sphinxhline
\sphinxAtStartPar
sim\_options
&
\sphinxAtStartPar
string/list of string
&
\sphinxAtStartPar
{\hyperref[\detokenize{api:table2}]{\sphinxcrossref{\DUrole{std,std-ref}{See table 2}}}}
&
\sphinxAtStartPar
Simulation options
\\
\sphinxhline
\sphinxAtStartPar
runtime\_options
&
\sphinxAtStartPar
list of string
&
\sphinxAtStartPar
{\hyperref[\detokenize{api:table3}]{\sphinxcrossref{\DUrole{std,std-ref}{See table 3}}}}
&
\sphinxAtStartPar
Runtime options
\\
\sphinxhline
\sphinxAtStartPar
global\_options
&
\sphinxAtStartPar
list of string
&
\sphinxAtStartPar
{\hyperref[\detokenize{api:table4}]{\sphinxcrossref{\DUrole{std,std-ref}{See table 4}}}}
&
\sphinxAtStartPar
Global options
\\
\sphinxhline
\sphinxAtStartPar
elab\_options
&
\sphinxAtStartPar
list of string
&
\sphinxAtStartPar
{\hyperref[\detokenize{api:table5}]{\sphinxcrossref{\DUrole{std,std-ref}{See table 5}}}}
&
\sphinxAtStartPar
Elaboration options
\\
\sphinxhline
\sphinxAtStartPar
netlist\_timing
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
None
&
\sphinxAtStartPar
Netlist timing settings
\\
\sphinxhline
\sphinxAtStartPar
keep\_code\_coverage
&
\sphinxAtStartPar
True/False (boolean)
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
Keep code coverage data
\\
\sphinxhline
\sphinxAtStartPar
no\_default\_com\_options
&
\sphinxAtStartPar
True/False (boolean)
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
Disable default options
\\
\sphinxhline
\sphinxAtStartPar
ignore\_simulator\_exit\_codes
&
\sphinxAtStartPar
list of int
&
\sphinxAtStartPar
{[}{]}
&
\sphinxAtStartPar
Ignore specific exit codes
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{n}{gui\PYGZus{}mode}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{threading}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{n}{netlist\PYGZus{}timing}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}sdfmin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{n}{sim\PYGZus{}options}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}t ps \PYGZhy{}do }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{quietly set NumericStdNoWarnings 1}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{api:table1}}
\sphinxAtStartPar
\sphinxstylestrong{Table 1: Compilation Options}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Simulator
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
ModelSim (VHDL)
&
\sphinxAtStartPar
{[}“\sphinxhyphen{}suppress”, “1346,1236,1090”, “\sphinxhyphen{}2008”{]}
\\
\sphinxhline
\sphinxAtStartPar
ModelSim (Verilog)
&
\sphinxAtStartPar
{[}“\sphinxhyphen{}vlog01compat”{]}
\\
\sphinxhline
\sphinxAtStartPar
NVC
&
\sphinxAtStartPar
{[}”\textendash{}relaxed”{]}
\\
\sphinxhline
\sphinxAtStartPar
GHDL
&
\sphinxAtStartPar
{[}”\textendash{}std=08”, “\textendash{}ieee=standard”, “\textendash{}frelaxed\sphinxhyphen{}rules”, “\textendash{}warn\sphinxhyphen{}no\sphinxhyphen{}shared”, “\textendash{}warn\sphinxhyphen{}no\sphinxhyphen{}hide”{]}
\\
\sphinxhline
\sphinxAtStartPar
Riviera Pro
&
\sphinxAtStartPar
{[}“\sphinxhyphen{}2008”, “\sphinxhyphen{}nowarn”, “COMP96\_0564”, “\sphinxhyphen{}nowarn”, “COMP96\_0048”, “\sphinxhyphen{}nowarn”, “DAGGEN\_0001”, “\sphinxhyphen{}dbg”{]}
\\
\sphinxhline
\sphinxAtStartPar
Vivado
&
\sphinxAtStartPar
{[}”\textendash{}2008”{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{api:table2}}
\sphinxAtStartPar
\sphinxstylestrong{Table 2: Simulation Options}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Simulator
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
ModelSim
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
NVC
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
GHDL
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Riviera Pro
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Vivado
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{api:table3}}
\sphinxAtStartPar
\sphinxstylestrong{Table 3: Runtime Options}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Simulator
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Modelsim
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
NVC
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
GHDL
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Riviera Pro
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Vivado
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{api:table4}}
\sphinxAtStartPar
\sphinxstylestrong{Table 4: Global Options}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Simulator
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Modelsim
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
NVC
&
\sphinxAtStartPar
{[}”\textendash{}stderr=error”, “\textendash{}messages=compact”, “\sphinxhyphen{}M64m”, “\sphinxhyphen{}H64m”{]}
\\
\sphinxhline
\sphinxAtStartPar
GHDL
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Riviera Pro
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Vivado
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{api:table5}}
\sphinxAtStartPar
\sphinxstylestrong{Table 5: Elaboration Options}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Simulator
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Modelsim
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
NVC
&
\sphinxAtStartPar
{[}“\sphinxhyphen{}e”, “\textendash{}no\sphinxhyphen{}save”, “\textendash{}jit”{]}
\\
\sphinxhline
\sphinxAtStartPar
GHDL
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Riviera Pro
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxhline
\sphinxAtStartPar
Vivado
&
\sphinxAtStartPar
{[}{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{gui\_mode}} selects if simulations should be run from terminal or inside {\hyperref[\detokenize{gui::doc}]{\sphinxcrossref{\DUrole{doc}{GUI}}}} \sphinxhyphen{} if supported by the simulator.
\item[] In GUI the simulator is started with predefined HDLRegression methods that simplyfies compilation and running tests.
\end{DUlineblock}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{regression\_mode}} selects run method, i.e. only run tests that:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
have not previously been run

\item {} 
\sphinxAtStartPar
have not passed

\item {} 
\sphinxAtStartPar
are affected by file changes and need to be rerun.

\end{enumerate}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stop\_on\_failure}} selects if the regression run shall continue running if a test fails.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{threading}} selects if tasks are run in parallel. Depending on the workload this can decrease run time of some
regression runs.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sim\_options}} adds extra commands to simulator executor call.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{netlist\_timing}} is a string that has to be set to “\sphinxhyphen{}sdfmin”, “\sphinxhyphen{}sdftyp” or “\sphinxhyphen{}sdfmax”.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{keep\_code\_coverage}} will keep code coverage results from a previous test run. This can be useful in situations where
a subset of tests needs to be rerun to achieve wanted code coverage.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{no\_default\_com\_options}} disables preconfigured settings for disabling the following warnings:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
vcom\sphinxhyphen{}1236: shared variables must be of a protected type

\item {} 
\sphinxAtStartPar
vcom\sphinxhyphen{}1346: default expression of interface object is not globally static

\item {} 
\sphinxAtStartPar
vcom\sphinxhyphen{}1090: possible infinite loop: process contains no WAIT statement

\end{enumerate}

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
\sphinxstylestrong{gui\_mode} will run testcases in one of these modes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
testcases added by the {\hyperref[\detokenize{api:add-testcase}]{\sphinxcrossref{add\_testcase()}}} method or using the {\hyperref[\detokenize{cli::doc}]{\sphinxcrossref{\DUrole{doc}{command line interfaces}}}}.

\item {} 
\sphinxAtStartPar
regression mode.

\end{enumerate}

\sphinxAtStartPar
starting with bullet point 1, and if no testcases have been added, moving on to bullet point 2.
\end{sphinxadmonition}


\section{Advanced methods}
\label{\detokenize{api:advanced-methods}}

\subsection{add\_file\_to\_run\_folder()}
\label{\detokenize{api:add-file-to-run-folder}}
\sphinxAtStartPar
Copies a single file to the testcase run folder.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}file\PYGZus{}to\PYGZus{}run\PYGZus{}folder}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{filename}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{tc\PYGZus{}id}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
filename
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
tc\_id
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}file\PYGZus{}to\PYGZus{}run\PYGZus{}folder}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/design/tb/input\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{tc\PYGZus{}id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{l+m+mf}{2.} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}file\PYGZus{}to\PYGZus{}run\PYGZus{}folder}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../tb/input\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{tc\PYGZus{}id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Relative paths will be relative to the regression script
and not where the regression script is called from.
\end{sphinxadmonition}


\subsection{add\_generics()}
\label{\detokenize{api:add-generics}}
\sphinxAtStartPar
Selects the generics to be used when running a testcase.
A test run is created when generics are added to a testcase, thus calling {\hyperref[\detokenize{api:add-generics}]{\sphinxcrossref{add\_generics()}}} two times will create
two test runs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}generics}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{entity}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{architecture}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{generics}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
entity
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
architecture
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
generics
&
\sphinxAtStartPar
list {[}string, int/string/bool{]}
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{important}{Important:}\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] All generics that are used for input or output files inside a testbench
will require the \sphinxcode{\sphinxupquote{PATH}} keyword when setting the generic in the regression script.
\item[] The generic value and the \sphinxcode{\sphinxupquote{PATH}} keyword has to be of a Python \sphinxstylestrong{tuple} type.
HDLRegression will make the adjustments for the generic paths to match HDLRegression test paths. See example 3.
\end{DUlineblock}

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}generics}\PYG{p}{(}\PYG{n}{entity}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}dut\PYGZus{}tb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{generics}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}BUS\PYGZus{}WIDTH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}ADDR\PYGZus{}WIDTH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}

\PYG{l+m+mf}{2.} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}generics}\PYG{p}{(}\PYG{n}{entity}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}dut\PYGZus{}tb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{architecture}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{generics}\PYG{o}{=}\PYG{n}{my\PYGZus{}generics\PYGZus{}list}\PYG{p}{)}

\PYG{l+m+mf}{3.} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}generics}\PYG{p}{(}\PYG{n}{entity}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}dut\PYGZus{}tb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{generics}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}DATA\PYGZus{}FILE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../test\PYGZus{}data/input\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PATH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}MASTER\PYGZus{}MODE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Relative paths will be relative to the regression script
and not where the regression script is called from.
\end{sphinxadmonition}


\subsection{add\_precompiled\_library()}
\label{\detokenize{api:add-precompiled-library}}
\sphinxAtStartPar
Specifies the name and path of a precompiled library.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The library will never be compiled and only a reference is added to the modelsim.ini file.
Any number of precompiled libraries can be added.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}precompiled\PYGZus{}library}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{compile\PYGZus{}path}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{library\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
compile\_path
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
library\_name
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{add\_testcase()}
\label{\detokenize{api:add-testcase}}
\sphinxAtStartPar
Adding testcase(s) will configure HDLRegression to only run these testcases.
All testcases are run if no testcases are added using this command.
Selecting testcase can also be done by using {\hyperref[\detokenize{cli::doc}]{\sphinxcrossref{\DUrole{doc}{command line interfaces}}}}, and testcases selected from CLI will
override any scripted testcase selecition.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
A testcase name is a string that consists of
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
testbench entity name

\item {} 
\sphinxAtStartPar
testbench architecture name

\item {} 
\sphinxAtStartPar
test name (optional)

\end{enumerate}

\sphinxAtStartPar
And where the three testcase name elements are separated by a dot (\sphinxcode{\sphinxupquote{.}}): \sphinxcode{\sphinxupquote{\textless{}testbench\_name\textgreater{}.\textless{}architecture\_name\textgreater{}.\textless{}test\_name\textgreater{}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Use wildcards to more effectively filter searches, i.e. testcases and filenames.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Pattern
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
*
&
\sphinxAtStartPar
match all
\\
\sphinxhline
\sphinxAtStartPar
?
&
\sphinxAtStartPar
match a single charecter
\\
\sphinxhline
\sphinxAtStartPar
{[}seq{]}
&
\sphinxAtStartPar
match any character in seq
\\
\sphinxhline
\sphinxAtStartPar
{[}!seq{]}
&
\sphinxAtStartPar
match all character not in seq
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}testcase}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{testcase}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstyleemphasis{testcase}
&
\sphinxAtStartPar
string / list of strings
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}testcase}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{interface\PYGZus{}tb.test\PYGZus{}arch.read\PYGZus{}test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} this test only}

\PYG{n}{add\PYGZus{}testcase}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{interface\PYGZus{}tb.*.read\PYGZus{}*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} all architectures and all sequencer testcases starting with \PYGZsq{}read\PYGZsq{}}

\PYG{n}{add\PYGZus{}testcase}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{interface\PYGZus{}tb.test\PYGZus{}arch.????\PYGZus{}test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} all sequencer testcases mathing any 4 character start, followed by \PYGZsq{}\PYGZus{}test\PYGZsq{}}

\PYG{n}{add\PYGZus{}testcase}\PYG{p}{(}\PYG{n}{interface\PYGZus{}tests\PYGZus{}list}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} a list of selected tests}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The {\hyperref[\detokenize{api:start}]{\sphinxcrossref{start()}}} method will return error code 1 if no testcases matched the \sphinxcode{\sphinxupquote{testcase}} keyword.
\end{sphinxadmonition}


\subsection{add\_to\_testgroup()}
\label{\detokenize{api:add-to-testgroup}}
\begin{DUlineblock}{0em}
\item[] Will add tests to a collection of tests, i.e. {\hyperref[\detokenize{intro:test-group}]{\sphinxcrossref{\DUrole{std,std-ref}{test group}}}}, that can be run in groups.
The test group is given a name that is used for addressing the test collection.
\item[] There are no limit for how many tests that can be added to a test group, and no limit for the number of test groups.
\item[] Running a test group can be done using a {\hyperref[\detokenize{cli::doc}]{\sphinxcrossref{\DUrole{doc}{command line interface}}}}.
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}testgroup}\PYG{p}{(}\PYG{n}{testgroup\PYGZus{}name}\PYG{p}{,} \PYG{n}{entity}\PYG{p}{,} \PYG{n}{architecture}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{testcase}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{generic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
testgroup\_name
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
entity
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
architecture
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
testcase
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
generic
&
\sphinxAtStartPar
list {[}string, int/string/bool{]}
&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{add\_to\_testgroup()}} adds existing tests to a collection, i.e. no new tests are created.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{testcase}} argument is for selecting sequencer built\sphinxhyphen{}in testcases.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{api:start}]{\sphinxcrossref{start()}}} method will return error code 1 if no test group or testcase were found.

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Use wildcards to more effectively filter searches, i.e. testcases and filenames.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Pattern
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
*
&
\sphinxAtStartPar
match all
\\
\sphinxhline
\sphinxAtStartPar
?
&
\sphinxAtStartPar
match a single charecter
\\
\sphinxhline
\sphinxAtStartPar
{[}seq{]}
&
\sphinxAtStartPar
match any character in seq
\\
\sphinxhline
\sphinxAtStartPar
{[}!seq{]}
&
\sphinxAtStartPar
match all character not in seq
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{compile\_uvvm()}
\label{\detokenize{api:compile-uvvm}}
\sphinxAtStartPar
Compiles UVVM to HDLRegression library folder, making UVVM available to all tests run by HDLRegression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{compile\PYGZus{}uvvm}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{path\PYGZus{}to\PYGZus{}uvvm}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
path\_to\_uvvm
&
\sphinxAtStartPar
“../ip/UVVM”
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{compile\PYGZus{}uvvm}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/development/tools/UVVM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{important}{Important:}\begin{itemize}
\item {} 
\sphinxAtStartPar
The UVVM path has to absolute or relative to the regression script location.

\end{itemize}
\end{sphinxadmonition}


\subsection{compile\_osvvm()}
\label{\detokenize{api:compile-osvvm}}
\sphinxAtStartPar
Compiles OSVVM to HDLRegression library folder, making OSVVM available to all tests run by HDLRegression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{compile\PYGZus{}osvvm}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{path\PYGZus{}to\PYGZus{}osvvm}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
path\_to\_osvvm
&
\sphinxAtStartPar
“../ip/OSVVM”
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{compile\PYGZus{}osvvm}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c:/development/tools/OSVVM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{important}{Important:}\begin{itemize}
\item {} 
\sphinxAtStartPar
The OSVVM path has to absolute or relative to the regression script location.

\end{itemize}
\end{sphinxadmonition}


\subsection{configure\_library()}
\label{\detokenize{api:configure-library}}
\sphinxAtStartPar
Set special settings for a library that differs significantly from the regular settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{configure\PYGZus{}library}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{library}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{never\PYGZus{}recompile}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{set\PYGZus{}lib\PYGZus{}dep}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Options
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
library
&
\sphinxAtStartPar
\sphinxstyleemphasis{library name} (string)
&
\sphinxAtStartPar
“can\_ip\_library”
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
never\_recompile
&
\sphinxAtStartPar
True/False (boolean)
&
\sphinxAtStartPar
True
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
set\_lib\_dep
&
\sphinxAtStartPar
\sphinxstyleemphasis{library name} (string)
&
\sphinxAtStartPar
“ip\_library”
&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{configure\PYGZus{}library}\PYG{p}{(}\PYG{n}{library}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{can\PYGZus{}ip\PYGZus{}library}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{never\PYGZus{}recompile}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{gen\_report()}
\label{\detokenize{api:gen-report}}
\sphinxAtStartPar
Writes a test run report file to the \sphinxcode{\sphinxupquote{hdlregression/test}} folder. The default report file is \sphinxcode{\sphinxupquote{report.txt}}
and can be changed using the \sphinxcode{\sphinxupquote{report\_file}} argument. The report file is saved in the \sphinxcode{\sphinxupquote{/hdlregression/test}} folder, thus no path
should be given to the report name.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gen\PYGZus{}report}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{report\PYGZus{}file}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{compile\PYGZus{}order}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{library}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Options \& Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
report\_file
&
\sphinxAtStartPar
\sphinxstyleemphasis{filename} (string)
&
\sphinxAtStartPar
“report.txt”
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
compile\_order
&
\sphinxAtStartPar
True / False (boolean)
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
library
&
\sphinxAtStartPar
True / False (boolean)
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{gen\PYGZus{}report}\PYG{p}{(}\PYG{n}{report\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sim\PYGZus{}report.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{compile\PYGZus{}order}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{gen\PYGZus{}report}\PYG{p}{(}\PYG{n}{report\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sim\PYGZus{}report.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{compile\PYGZus{}order}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{library}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
Supported file types are \sphinxcode{\sphinxupquote{.txt}}, \sphinxcode{\sphinxupquote{.csv}}, \sphinxcode{\sphinxupquote{.xml}} and \sphinxcode{\sphinxupquote{.json}} and the file type is extracted from the file name.
\end{sphinxadmonition}


\subsection{get\_args()}
\label{\detokenize{api:get-args}}
\sphinxAtStartPar
The command is used for getting the parsed arguments from HDLRegression.
This method can be used when there is a argparser object that is created in the regression script.
See {\hyperref[\detokenize{api:hdlregression}]{\sphinxcrossref{HDLRegression()}}} example 2 for usage.

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{args} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}args}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{get\_file\_list()}
\label{\detokenize{api:get-file-list}}
\sphinxAtStartPar
The command is used for reading back the files added to the libraries in HDLRegression.
All files from all libraries are returned in a list.

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{file\PYGZus{}list} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}file\PYGZus{}list}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{remove\_file()}
\label{\detokenize{api:remove-file}}
\sphinxAtStartPar
Removes a file that has been added to a library, e.g. after using \sphinxcode{\sphinxupquote{add\_files()}} with asterix for adding several files.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{remove\PYGZus{}file}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{filename}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{library\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
filename
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
library\_name
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testbench\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{remove\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unused\PYGZus{}file.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testbench\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The filename can not include the path to the file or any wildcards.
\end{sphinxadmonition}


\subsection{run\_command()}
\label{\detokenize{api:run-command}}
\sphinxAtStartPar
The command is executed by HLDRegression at the given stage in the regression script. I.e. pre\sphinxhyphen{}simulation commands will have
to be called prior to {\hyperref[\detokenize{api:start}]{\sphinxcrossref{start()}}} and post\sphinxhyphen{}simulation commands need to be called after {\hyperref[\detokenize{api:start}]{\sphinxcrossref{start()}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{run\PYGZus{}command}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{command}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
command
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
verbose
&
\sphinxAtStartPar
boolean
&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
No output is printed to the terminal by default, but this can
be changed by setting the \sphinxcode{\sphinxupquote{verbose}} argument to \sphinxcode{\sphinxupquote{True}}.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{run\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{python3 ../script/run\PYGZus{}spec\PYGZus{}cov.py \PYGZhy{}\PYGZhy{}config ../script/config.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{run\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vsim \PYGZhy{}version}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Relative paths will be relative to the regression script
and not where the regression script is called from.
\end{sphinxadmonition}


\subsection{set\_code\_coverage()}
\label{\detokenize{api:set-code-coverage}}
\sphinxAtStartPar
Sets the code coverage settings used when running the tests.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}code\PYGZus{}coverage}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{code\PYGZus{}coverage\PYGZus{}settings}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{code\PYGZus{}coverage\PYGZus{}file}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{exclude\PYGZus{}file}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{merge\PYGZus{}options}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
code\_coverage\_settings
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
“bcst”
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
code\_coverage\_file
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
“coverage.ucdb”
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
exclude\_file
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
“exceptions.tcl”
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
merge\_options
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
“\sphinxhyphen{}testassociated”
&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{api:add-files}]{\sphinxcrossref{add\_files()}}} require the \sphinxcode{\sphinxupquote{code\_coverage}} argument enabled for every file that should sample code coverage.

\item {} 
\sphinxAtStartPar
Each test run will generate a \sphinxcode{\sphinxupquote{code\_coverage\_file}} inside its test folder.

\item {} 
\sphinxAtStartPar
Results from the regression are accumulated in a \sphinxcode{\sphinxupquote{code\_coverage\_file}} \sphinxcode{\sphinxupquote{\_merge}} file inside the
\sphinxcode{\sphinxupquote{test/coverage/}} folder.

\item {} 
\sphinxAtStartPar
Exceptions are filtered from the accumulated file automatically in a \sphinxcode{\sphinxupquote{code\_coverage\_file}} \sphinxcode{\sphinxupquote{\_filter}} file
inside the \sphinxcode{\sphinxupquote{test/coverage/}} folder.

\item {} 
\sphinxAtStartPar
Reports are written to the \sphinxcode{\sphinxupquote{test/coverage/txt}} and \sphinxcode{\sphinxupquote{test/coverage/html}} folders using the filtered
exception results if a \sphinxcode{\sphinxupquote{exlude\_file}} is set, or using the merged code coverage results if no \sphinxcode{\sphinxupquote{exclude\_file}} is set.

\item {} 
\sphinxAtStartPar
Only the current test run is used for code coverage, meaning that a full regression run is required to sample
code coverage for the complete test suite.

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}code\PYGZus{}coverage}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bcst}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{code\PYGZus{}coverage.ucdb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}code\PYGZus{}coverage}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bcst}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{code\PYGZus{}coverage.ucdb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exclude.tcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{set\_dependency()}
\label{\detokenize{api:set-dependency}}
\sphinxAtStartPar
Specifies the libraries that have a dependency to the \sphinxcode{\sphinxupquote{library\_name}} library, and ensures that \sphinxcode{\sphinxupquote{library\_name}} is
compiled after all of the libraries listed in \sphinxcode{\sphinxupquote{dep\_library}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set\PYGZus{}dependency}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{library\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{dep\PYGZus{}library}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
library\_name
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
dep\_library
&
\sphinxAtStartPar
list {[}string{]}
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Specifying the library dependency is usually not necessary as HDLRegression is capable of detecting dependencies.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dep\_library}} list has to be a list of library name(s).

\end{enumerate}
\end{sphinxadmonition}


\subsection{set\_result\_check\_string()}
\label{\detokenize{api:set-result-check-string}}
\sphinxAtStartPar
The result of a test run is determined by scanning the simulation log file, searching after a specific string.
If the string is found the test run is set as \sphinxstylestrong{PASS}, and \sphinxstylestrong{FAIL} otherwise, thus only a passing test should
report the check string.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set\PYGZus{}result\PYGZus{}check\PYGZus{}string}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{check\PYGZus{}string}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
check\_string
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The default test pass string is the UVVM \sphinxcode{\sphinxupquote{report\_alert\_counters(FINAL)}} summary, with \sphinxcode{\sphinxupquote{SUCCESS}} as
criteria for a passing test.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}result\PYGZus{}check\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testcase passed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Example TB with testcase result string}
\def\sphinxLiteralBlockLabel{\label{\detokenize{api:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{p\PYGZus{}seq}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{process}
\PYG{+w}{    }\PYG{k}{variable}\PYG{+w}{ }\PYG{n}{v\PYGZus{}check\PYGZus{}ok}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{boolean}\PYG{+w}{ }\PYG{o}{:}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{false}\PYG{p}{;}
\PYG{k}{begin}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} testcase checks, e.g.}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} v\PYGZus{}check\PYGZus{}ok := check\PYGZus{}value(v\PYGZus{}act\PYGZus{}data, v\PYGZus{}exp\PYGZus{}data, error, \PYGZdq{}checking receive data\PYGZdq{}, C\PYGZus{}SCOPE);}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{n}{v\PYGZus{}check\PYGZus{}ok}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{true}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{        }\PYG{n}{report}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}testcase passed\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{end}\PYG{+w}{ }\PYG{k}{if}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Finish the simulation}
\PYG{+w}{    }\PYG{n+nn}{std}\PYG{n+nn}{.env}\PYG{p}{.}\PYG{n}{stop}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{wait}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} to stop completely}
\PYG{k}{end}\PYG{+w}{ }\PYG{k}{process}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{set\_simulator()}
\label{\detokenize{api:set-simulator}}
\sphinxAtStartPar
HDLRegression is configured to run using Modelsim and VHDL version 2008 as default. This method allows for changing
\begin{itemize}
\item {} 
\sphinxAtStartPar
Simulator

\item {} 
\sphinxAtStartPar
Simulator executable path

\item {} 
\sphinxAtStartPar
Simulator com\_options

\end{itemize}

\begin{DUlineblock}{0em}
\item[] This can be useful when the test script should be run with a different version of Modelsim other than the
one listed in the system path, where all that is needed is to change the path for the Modelsim executable.
\item[] It is also possible to select simulator when initializing the {\hyperref[\detokenize{api:hdlregression}]{\sphinxcrossref{\DUrole{std,std-ref}{HDLRegression}}}} object, but without selecting
compile options and setting simulator executable path, or by using {\hyperref[\detokenize{cli::doc}]{\sphinxcrossref{\DUrole{doc}{command line interfaces}}}}.
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set\PYGZus{}simulator}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{simulator}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{simulator\PYGZus{}path}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{com\PYGZus{}options}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Options
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
simulator
&
\sphinxAtStartPar
\sphinxstyleemphasis{simulator name} (string)
&
\sphinxAtStartPar
“MODELSIM”/”GHDL”/”NVC”/”RIVIERA\_PRO”
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxhline
\sphinxAtStartPar
simulator\_path
&
\sphinxAtStartPar
\sphinxstyleemphasis{simulator\_executable\_path} (string)
&
\sphinxAtStartPar
“c:/ghdl/bin”
&
\sphinxAtStartPar
optional
\\
\sphinxhline
\sphinxAtStartPar
com\_options
&
\sphinxAtStartPar
\sphinxstyleemphasis{compile optionss} (string/list of string)
&
\sphinxAtStartPar
“\sphinxhyphen{}suppress 1346,1236,1090 \sphinxhyphen{}2008”
&
\sphinxAtStartPar
optional
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulator}\PYG{p}{(}\PYG{n}{simulator}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GHDL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulator}\PYG{p}{(}\PYG{n}{simulator}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MODELSIM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c:/tools/intelFPGA/20.1/modelsim\PYGZus{}ase/win32aloem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
All path slashes has to be written as forward slash / .
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Relative paths will be relative to the regression script
and not where the regression script is called from.
\end{sphinxadmonition}


\subsection{set\_testcase\_identifier\_name()}
\label{\detokenize{api:set-testcase-identifier-name}}
\sphinxAtStartPar
Sets the name of the testcase generic used when defining several testcases
inside a single testbench architecture. The default testcase generic is \sphinxcode{\sphinxupquote{GC\_TESTCASE}},
but any name can be given.

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\sphinxAtStartPar
The sequencer built\sphinxhyphen{}in testcase if\sphinxhyphen{}structure will need to match this generic.

\item {} 
\sphinxAtStartPar
HDLRegression extracts all the sequencer built\sphinxhyphen{}in testcases based on the combined usage of this generic
and if\sphinxhyphen{}matched strings.

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}testcase\PYGZus{}identifier\PYGZus{}name}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{testcase\PYGZus{}id}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
testcase\_id
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}testcase\PYGZus{}identifier\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}TESTCASE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Example TB with testcase ID generic}
\def\sphinxLiteralBlockLabel{\label{\detokenize{api:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}hdlregression:tb}
\PYG{k}{entity}\PYG{+w}{ }\PYG{n+nc}{tb\PYGZus{}top}\PYG{+w}{ }\PYG{k}{is}
\PYG{+w}{    }\PYG{k}{generic}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{        }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{o}{:}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}read\PYGZus{}test\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{k}{end}\PYG{+w}{ }\PYG{n+nc}{tb\PYGZus{}top}\PYG{p}{;}

\PYG{k}{architecture}\PYG{+w}{ }\PYG{n+nc}{test}\PYG{+w}{ }\PYG{k}{of}\PYG{+w}{ }\PYG{n+nc}{simple\PYGZus{}tb}\PYG{+w}{ }\PYG{k}{is}
\PYG{+w}{    }\PYG{k}{constant}\PYG{+w}{ }\PYG{n}{C\PYGZus{}SCOPE}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{o}{:}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}SIMPLE\PYGZus{}TB\PYGZdq{}}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{  }\PYG{k}{begin}
\PYG{+w}{    }\PYG{n}{p\PYGZus{}main}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{process}\PYG{+w}{  }
\PYG{+w}{    }\PYG{k}{begin}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}read\PYGZus{}test\PYGZdq{}}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{            }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} read tests}
\PYG{+w}{        }\PYG{k}{elsif}\PYG{+w}{ }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}write\PYGZus{}test\PYGZdq{}}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{            }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} write tests}
\PYG{+w}{        }\PYG{k}{else}
\PYG{+w}{            }\PYG{n}{report}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Unknown test \PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{end}\PYG{+w}{ }\PYG{k}{if}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Finish the simulation}
\PYG{+w}{    }\PYG{n+nn}{std}\PYG{n+nn}{.env}\PYG{p}{.}\PYG{n}{stop}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{wait}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} to stop completely        }
\PYG{+w}{    }\PYG{k}{end}\PYG{+w}{ }\PYG{k}{process}\PYG{p}{;}
\PYG{k}{end}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{set\_simulator\_wave\_file\_format()}
\label{\detokenize{api:set-simulator-wave-file-format}}
\sphinxAtStartPar
Sets the wave dump format for GHDL and NVC wave files. Options are FST and VCD.

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\sphinxAtStartPar
VCD file format is default if no other is selected.

\item {} 
\sphinxAtStartPar
GUI mode has to be enabled using API method or CLI option.

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulator\PYGZus{}wave\PYGZus{}file\PYGZus{}format}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{wave\PYGZus{}format}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Required
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
wave\_format
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
\sphinxstylestrong{mandatory}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulator\PYGZus{}wave\PYGZus{}file\PYGZus{}format}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VCD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{n}{gui\PYGZus{}mode}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Statistical methods}
\label{\detokenize{api:statistical-methods}}

\subsection{get\_results()}
\label{\detokenize{api:get-results}}
\sphinxAtStartPar
Returns a list of all passed, failed and not run tests.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result\PYGZus{}list} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{passed\PYGZus{}tests} \PYG{o}{=} \PYG{n}{result\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{failed\PYGZus{}tests} \PYG{o}{=} \PYG{n}{result\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{not\PYGZus{}run\PYGZus{}tests} \PYG{o}{=} \PYG{n}{result\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{passed\PYGZus{}tests}\PYG{p}{,} \PYG{n}{failed\PYGZus{}tests}\PYG{p}{,} \PYG{n}{not\PYGZus{}run\PYGZus{}tests}\PYG{p}{)} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{get\_num\_tests\_run()}
\label{\detokenize{api:get-num-tests-run}}
\sphinxAtStartPar
Returns the number of tests run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}tests\PYGZus{}run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}tests} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}tests\PYGZus{}run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{get\_num\_pass\_tests()}
\label{\detokenize{api:get-num-pass-tests}}
\sphinxAtStartPar
Returns the number of passed test runs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}pass\PYGZus{}tests}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}passed\PYGZus{}tests} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}pass\PYGZus{}tests}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{get\_num\_fail\_tests()}
\label{\detokenize{api:get-num-fail-tests}}
\sphinxAtStartPar
Returns the number of failed test runs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}fail\PYGZus{}tests}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}failed\PYGZus{}tests} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}fail\PYGZus{}tests}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{get\_num\_pass\_with\_minor\_alert\_tests()}
\label{\detokenize{api:get-num-pass-with-minor-alert-tests}}
\sphinxAtStartPar
Returns the number of passed test runs that completed with minor alerts.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This is only applicable for tests run with the UVVM verification framework.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}pass\PYGZus{}with\PYGZus{}minor\PYGZus{}alert\PYGZus{}tests}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}passed\PYGZus{}tests\PYGZus{}with\PYGZus{}minor\PYGZus{}alerts} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{get\PYGZus{}num\PYGZus{}pass\PYGZus{}with\PYGZus{}minor\PYGZus{}alert\PYGZus{}tests}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Command Line Interface (CLI)}
\label{\detokenize{cli:command-line-interface-cli}}\label{\detokenize{cli::doc}}
\begin{DUlineblock}{0em}
\item[] The configuration of a regression run can be set directly from the command line using command line interface.
This can be useful when debugging the behaviour of a design, e.g. by running in {\hyperref[\detokenize{gui::doc}]{\sphinxcrossref{\DUrole{doc}{GUI mode}}}},
or working with a {\hyperref[\detokenize{intro:testcase}]{\sphinxcrossref{\DUrole{std,std-ref}{testcase}}}} or {\hyperref[\detokenize{intro:test-group}]{\sphinxcrossref{\DUrole{std,std-ref}{test group}}}}.
\item[] The command line interface are processed at startup and will override any scripted configurations that are in conflict.
\end{DUlineblock}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily \sphinxAtStartPar
Arguments
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxhyphen{}h
&
\sphinxAtStartPar
\textendash{}help
&
\sphinxAtStartPar
Help screen
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}v
&
\sphinxAtStartPar
\textendash{}verbose
&
\sphinxAtStartPar
Enable full verbosity
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}d
&
\sphinxAtStartPar
\textendash{}debug
&
\sphinxAtStartPar
Enable debug mode
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}g
&
\sphinxAtStartPar
\textendash{}gui
&
\sphinxAtStartPar
Run with simulator gui
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}fr
&
\sphinxAtStartPar
\textendash{}fullRegression
&
\sphinxAtStartPar
Run all tests
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}c
&
\sphinxAtStartPar
\textendash{}clean
&
\sphinxAtStartPar
Remove all before test run
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}tc TB\_ENTITY {[}TB\_ARCH {[}TC{]}{]}
&
\sphinxAtStartPar
\textendash{}testCase TB\_ENTITY {[}TB\_ARCH {[}TC{]}{]}
&
\sphinxAtStartPar
Run selected testcase
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}tg TESTGROUP
&
\sphinxAtStartPar
\textendash{}testGroup TESTGROUP
&
\sphinxAtStartPar
Run selected test group
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}ltc
&
\sphinxAtStartPar
\textendash{}listTestcase
&
\sphinxAtStartPar
List all discovered testcases
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}ltg
&
\sphinxAtStartPar
\textendash{}listTestgroup
&
\sphinxAtStartPar
List all test groups
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}lco
&
\sphinxAtStartPar
\textendash{}listCompileOrder
&
\sphinxAtStartPar
List libraries and files in compile order
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}fc
&
\sphinxAtStartPar
\textendash{}forceCompile
&
\sphinxAtStartPar
Force recompile
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}sof
&
\sphinxAtStartPar
\textendash{}stopOnFailure
&
\sphinxAtStartPar
Stop simulations on testcase fail
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}s
&
\sphinxAtStartPar
\textendash{}simulator
&
\sphinxAtStartPar
Set simulator (require path in env)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}t
&
\sphinxAtStartPar
\textendash{}threading {[}N{]}
&
\sphinxAtStartPar
Run tasks in parallel
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}ns
&
\sphinxAtStartPar
\textendash{}no\_sim
&
\sphinxAtStartPar
No simulation, compile only
\\
\sphinxhline&
\sphinxAtStartPar
\textendash{}showWarnError
&
\sphinxAtStartPar
Show sim error and warning messages.
\\
\sphinxhline&
\sphinxAtStartPar
\textendash{}noColor
&
\sphinxAtStartPar
Disable terminal output colors.
\\
\sphinxhline&
\sphinxAtStartPar
\textendash{}waveFormat
&
\sphinxAtStartPar
Wave file format {[}VCD (default) or FST{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Examples}
\label{\detokenize{cli:examples}}

\subsection{Full regression}
\label{\detokenize{cli:full-regression}}
\sphinxAtStartPar
Enabling the {\hyperref[\detokenize{intro:what-is-regression-testing}]{\sphinxcrossref{\DUrole{std,std-ref}{full regression mode}}}} ensures that all testcases are run, regardless
of any previous runs, i.e. re\sphinxhyphen{}running the complete test suite.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}fr}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{full_regression}.png}\hspace*{\fill}}


\subsection{Testcases}
\label{\detokenize{cli:testcases}}
\sphinxAtStartPar
All tests that are discovered by HDLRegression can be listed using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}ltc}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}listTestcase}} argument, and
are listed as \sphinxcode{\sphinxupquote{\textless{}testbench entity\textgreater{}.\textless{}testbench architecture\textgreater{}.\textless{}sequencer built\sphinxhyphen{}in testcase\textgreater{}}} or just
\sphinxcode{\sphinxupquote{\textless{}testbench entity\textgreater{}.\textless{}testbench architecture\textgreater{}}} if no sequencer built\sphinxhyphen{}in testcases are used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}ltc}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{testcase_listing}.png}\hspace*{\fill}}

\sphinxAtStartPar
Running a selected test is done using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}tc \textless{}testbench.architecture.testcase\textgreater{}}} or
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}testCase \textless{}testbench.architecture.testcase\textgreater{}}} argument

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Use wildcards to more effectively filter searches, i.e. testcases and filenames.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Pattern
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
*
&
\sphinxAtStartPar
match all
\\
\sphinxhline
\sphinxAtStartPar
?
&
\sphinxAtStartPar
match a single charecter
\\
\sphinxhline
\sphinxAtStartPar
{[}seq{]}
&
\sphinxAtStartPar
match any character in seq
\\
\sphinxhline
\sphinxAtStartPar
{[}!seq{]}
&
\sphinxAtStartPar
match all character not in seq
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}tc uart\PYGZus{}vvc\PYGZus{}tb.func.check\PYGZus{}simple\PYGZus{}receive}
\end{sphinxVerbatim}

\sphinxAtStartPar
A testcase can also be selected using the testcase number from the \sphinxcode{\sphinxupquote{\sphinxhyphen{}ltc}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}listTestcase}} argument

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}tc 5}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{testcase_running}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Testcases are identified by:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\textless{}entity\_name\textgreater{}

\item {} 
\sphinxAtStartPar
\textless{}entity\_name\textgreater{}.\textless{}architecture\_name\textgreater{}

\item {} 
\sphinxAtStartPar
\textless{}entity\_name\textgreater{}.\textless{}architecture\_name\textgreater{}.\textless{}sequencer\_testcase\textgreater{}

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] When selecting testcases to run, you can utilize wildcards to simplify the process. However, it’s important to
note that the test case identifier must follow a specific naming convention.
\item[] For example, if you want to run all sequencer testcases that contain the word “write,” you would need to specify
the identifier as \textless{}entity\_name\textgreater{}.\textless{}architecture\_name\textgreater{}.write.
\item[] Note that you can also use wildcards for \textless{}entity\_name\textgreater{} and/or \textless{}architecture\_name\textgreater{} to further
refine your filter.
\end{DUlineblock}
\end{sphinxadmonition}


\subsection{Test groups}
\label{\detokenize{cli:test-groups}}
\sphinxAtStartPar
Listing of test groups that have been defined in the regression script. In the code snippet below there are defined
two test groups, \sphinxtitleref{transmit\_tests} and \sphinxtitleref{receive\_tests}, that will run all testcases that have \sphinxtitleref{transmit} and \sphinxtitleref{receive}
in the testcase name, and is defined in testbench \sphinxtitleref{uart\_vvc\_tb} architecture \sphinxtitleref{func}.
There is also a test group \sphinxtitleref{selection\_tests} that will run all testcases that are part of the \sphinxtitleref{uart\_vvc\_demo\_tb} and
\sphinxtitleref{uart\_simple\_bfm\_tb} entities.


\subsubsection{Defining test groups}
\label{\detokenize{cli:defining-test-groups}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}testgroup}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transmit\PYGZus{}tests}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uart\PYGZus{}vvc\PYGZus{}tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{func}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*transmit*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} run all transmit related tests}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}testgroup}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{receive\PYGZus{}tests}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uart\PYGZus{}vvc\PYGZus{}tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{func}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*receive*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} run all receive related tests}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}testgroup}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{selection\PYGZus{}tests}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{entity}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uart\PYGZus{}vvc\PYGZus{}demo\PYGZus{}tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} run this testbench}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}testgroup}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{selection\PYGZus{}tests}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{entity}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uart\PYGZus{}simple\PYGZus{}bfm\PYGZus{}tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}        \PYG{c+c1}{\PYGZsh{} run this testbench}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Use wildcards to more effectively filter searches, i.e. testcases and filenames.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Pattern
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
*
&
\sphinxAtStartPar
match all
\\
\sphinxhline
\sphinxAtStartPar
?
&
\sphinxAtStartPar
match a single charecter
\\
\sphinxhline
\sphinxAtStartPar
{[}seq{]}
&
\sphinxAtStartPar
match any character in seq
\\
\sphinxhline
\sphinxAtStartPar
{[}!seq{]}
&
\sphinxAtStartPar
match all character not in seq
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsubsection{Listing test groups}
\label{\detokenize{cli:listing-test-groups}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}ltg}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{testgroup_listing}.png}\hspace*{\fill}}


\subsubsection{Running test groups}
\label{\detokenize{cli:running-test-groups}}
\sphinxAtStartPar
Running one of the test groups, e.g. \sphinxtitleref{receive\_tests}, will run all tests with names that matches:
\begin{itemize}
\item {} 
\sphinxAtStartPar
testbench entity with \sphinxcode{\sphinxupquote{uart\_vvc\_tb}}

\item {} 
\sphinxAtStartPar
testbench architecture with \sphinxcode{\sphinxupquote{func}}

\item {} 
\sphinxAtStartPar
sequencer built\sphinxhyphen{}in testcase with \sphinxcode{\sphinxupquote{receive}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}\PYGZhy{}testGroup receive\PYGZus{}tests}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{testgroup_running}.png}\hspace*{\fill}}


\section{Threading}
\label{\detokenize{cli:threading}}
\sphinxAtStartPar
HDLRegression will run all tasks (pre\sphinxhyphen{}processing and testcase simulations) in a sequential order, but this can be changed
using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}t}} / \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}threading}} option, and optioinally with a number of threads.

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Running simulations in parallel using \sphinxcode{\sphinxupquote{N}} threads may require \sphinxcode{\sphinxupquote{N}} simulator licenses.

\item {} \begin{description}
\sphinxlineitem{Pre\sphinxhyphen{}processing threads are scaled to:}
\sphinxAtStartPar
\sphinxhyphen{}\textgreater{} the number of libraries

\sphinxAtStartPar
\sphinxhyphen{}\textgreater{} the number of files in each library

\sphinxAtStartPar
\sphinxhyphen{}\textgreater{} the number of parsers

\end{description}

\end{itemize}
\end{sphinxadmonition}


\subsection{Sequential}
\label{\detokenize{cli:sequential}}
\sphinxAtStartPar
All pre\sphinxhyphen{}processing steps and testcase running are performed sequentially.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}tg receive\PYGZus{}tests}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{testgroup_running}.png}\hspace*{\fill}}


\subsection{Pre\sphinxhyphen{}processing in parallel, simulations sequentially}
\label{\detokenize{cli:pre-processing-in-parallel-simulations-sequentially}}
\sphinxAtStartPar
All pre\sphinxhyphen{}processing steps are performed in parallel and testcase running is performed sequentially.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}tg receive\PYGZus{}tests \PYGZhy{}t}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{testgroup_threading_1}.png}\hspace*{\fill}}


\subsection{Pre\sphinxhyphen{}processing and simulations in parallel using 10 threads}
\label{\detokenize{cli:pre-processing-and-simulations-in-parallel-using-10-threads}}
\sphinxAtStartPar
All pre\sphinxhyphen{}processing steps and testcase running is performed in parallel.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}tg receive\PYGZus{}tests \PYGZhy{}t 10}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{testgroup_threading_10}.png}\hspace*{\fill}}


\section{Simulation results}
\label{\detokenize{cli:simulation-results}}
\sphinxAtStartPar
Running simulations in terminal will output the necessary information, such as the testcase name, generics used,
simulation run time and result.


\subsection{Regression initial run}
\label{\detokenize{cli:regression-initial-run}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{regression_run_1}.png}\hspace*{\fill}}


\subsection{Regression run without changes}
\label{\detokenize{cli:regression-run-without-changes}}
\sphinxAtStartPar
No tests are run when no changes are detected in the DUT or testcase files, unless full regression is enabled using
the {\hyperref[\detokenize{cli::doc}]{\sphinxcrossref{\DUrole{doc}{Command Line Interface (CLI)}}}} \sphinxcode{\sphinxupquote{\sphinxhyphen{}fr}} or using the {\hyperref[\detokenize{api::doc}]{\sphinxcrossref{\DUrole{doc}{Application Programming Interface (API)}}}} in the regression script \sphinxcode{\sphinxupquote{hr.start(full\_regression=True)}}.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{regression_run_2}.png}\hspace*{\fill}}


\subsection{Failing testcase run}
\label{\detokenize{cli:failing-testcase-run}}
\sphinxAtStartPar
A failing testcase will be reported as \sphinxstylestrong{FAIL} with a short summary from the test log:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=1000\sphinxpxdimen]{{failing_testcase}.png}\hspace*{\fill}}

\sphinxstepscope


\chapter{Graphical User Interface (GUI)}
\label{\detokenize{gui:graphical-user-interface-gui}}\label{\detokenize{gui::doc}}

\section{Modelsim}
\label{\detokenize{gui:modelsim}}
\sphinxAtStartPar
Sometimes debugging a design or test require the use of GUI (graphical user interface)
and HDLRegression can run tests in GUI when called with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}g}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}gui}} arugument.
When enabled, the regression script will open inside Modelsim GUI with a loaded testcase ready to run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}tc uart\PYGZus{}vvc\PYGZus{}tb.func.check\PYGZus{}simple\PYGZus{}transmit \PYGZhy{}g}
\end{sphinxVerbatim}

\sphinxAtStartPar
HDLRegression in GUI mode provides a set of functions for compiling and running a
test:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=550\sphinxpxdimen]{{gui_menu}.png}\hspace*{\fill}}


\section{GHDL}
\label{\detokenize{gui:ghdl}}
\sphinxAtStartPar
GHDL does not have a GUI, but can create simulation waveform files that can be opened to have a graphical representation
of the signals in a VCD format (Value Change Dump).

\sphinxAtStartPar
When HDLRegression is called with GUI arguments and runnning with GHDL simulator it will create \sphinxcode{\sphinxupquote{sim.vcd}} files
inside every testcase run folder. The VCD files can then be opened in a graphical wavefarm viewer such as GTKWave.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python ../test/regression.py \PYGZhy{}tc uart\PYGZus{}vvc\PYGZus{}tb.func.check\PYGZus{}simple\PYGZus{}transmit \PYGZhy{}g \PYGZhy{}s ghdl}
\PYG{g+go}{\PYGZgt{} gtkwave ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/54005228/sim.vcd \PYGZam{}}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Testbench}
\label{\detokenize{testbench:testbench}}\label{\detokenize{testbench::doc}}
\sphinxAtStartPar
For HDLRegression to extract the correct information from the testbench files, there are some
code requirements that have to be fulfilled. This information is used by HDLRegression to
detect


\section{Prerequisites}
\label{\detokenize{testbench:prerequisites}}
\sphinxAtStartPar
This are the requirements of a HDLRegression supporting testbench:
\begin{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The testbench file has to have the HDLRegression pragma above the entity declaration:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Only the top testbench file can have the HDLRegression testbench pragma.

\item {} 
\sphinxAtStartPar
Each top level testbench file has to have the HDLRegression testbench pragma.

\end{itemize}

\item {} 
\sphinxAtStartPar
A testbench simulation result report will have to match the {\hyperref[\detokenize{api:set-result-check-string}]{\sphinxcrossref{\DUrole{std,std-ref}{set\_result\_check\_string()}}}} to
\sphinxstylestrong{PASS}, and the test run will \sphinxstylestrong{FAIL} if this string is not found in the simulation transcript.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
UVVM \sphinxcode{\sphinxupquote{report\_alert\_counters(FINAL)}} is the default method for verifying a passing or failing test, and will have
to be added to the testbench if no other \sphinxcode{\sphinxupquote{check\_string}} is selected. See example testbench for suggested
implementation.
\end{sphinxadmonition}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{VHDL} testbench

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}HDLRegression:TB}
\PYG{k}{entity}\PYG{+w}{ }\PYG{n+nc}{my\PYGZus{}dut\PYGZus{}tb}\PYG{+w}{ }\PYG{k}{is}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Verilog} testbench

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//HDLRegression:TB}
\PYG{k}{module}\PYG{+w}{ }\PYG{n}{my\PYGZus{}dut\PYGZus{}tb}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\# A testbench with multiple testcases requires the GC\_TESTCASE generic (VHDL) or TESTCASE parameter
(Verilog), and these should only be used in the top level testbench entity.

\sphinxAtStartPar
\# The testcase names will be included in simulation reports.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{o}{:}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} VHDL}
\PYG{n}{parameter}\PYG{+w}{ }\PYG{n}{TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{     }\PYG{o}{/}\PYG{o}{/}\PYG{+w}{ }\PYG{n}{Verilog}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Note that the \sphinxcode{\sphinxupquote{GC\_TESTCASE}} generic or \sphinxcode{\sphinxupquote{TESTCASE}} parameter name can be changed using
the {\hyperref[\detokenize{api:set-testcase-identifier-name}]{\sphinxcrossref{\DUrole{std,std-ref}{set\_testcase\_identifier\_name()}}}} method.


\section{Example Testbench}
\label{\detokenize{testbench:example-testbench}}
\sphinxAtStartPar
For HDLRegression to discover a VHDL file to be used as a testbench the only requirement is that
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}hdlregression:tb}} (VHDL) or \sphinxcode{\sphinxupquote{//hdlregression:tb}} (Verilog) pragma is present:
\sphinxSetupCaptionForVerbatim{VHDL testbench example}
\def\sphinxLiteralBlockLabel{\label{\detokenize{testbench:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{library}\PYG{+w}{ }\PYG{n+nn}{IEEE}\PYG{p}{;}
\PYG{k}{use}\PYG{+w}{ }\PYG{n+nn}{IEEE.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use}\PYG{+w}{ }\PYG{n+nn}{IEEE.numeric\PYGZus{}std.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{library}\PYG{+w}{ }\PYG{n+nn}{uvvm\PYGZus{}util}\PYG{p}{;}
\PYG{n}{context}\PYG{+w}{ }\PYG{n}{uvvm\PYGZus{}util}\PYG{p}{.}\PYG{n}{uvvm\PYGZus{}util\PYGZus{}context}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Include when using VVC:}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} library uvvm\PYGZus{}vvc\PYGZus{}framework;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} use uvvm\PYGZus{}vvc\PYGZus{}framework.ti\PYGZus{}vvc\PYGZus{}framework\PYGZus{}support\PYGZus{}pkg.all;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{}hdlregression:tb}
\PYG{k}{entity}\PYG{+w}{ }\PYG{n+nc}{tb\PYGZus{}example}\PYG{+w}{ }\PYG{k}{is}
\PYG{+w}{  }\PYG{k}{generic}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{ }\PYG{o}{:}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}UVVM\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}\PYG{p}{;}
\PYG{k}{end}\PYG{+w}{ }\PYG{k}{entity}\PYG{+w}{ }\PYG{n+nc}{tb\PYGZus{}example}\PYG{p}{;}

\PYG{k}{architecture}\PYG{+w}{ }\PYG{n+nc}{func}\PYG{+w}{ }\PYG{k}{of}\PYG{+w}{ }\PYG{n+nc}{tb\PYGZus{}example}\PYG{+w}{ }\PYG{k}{is}

\PYG{+w}{  }\PYG{k}{constant}\PYG{+w}{ }\PYG{n}{C\PYGZus{}SCOPE}\PYG{+w}{      }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{string}\PYG{+w}{  }\PYG{o}{:}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{C\PYGZus{}TB\PYGZus{}SCOPE\PYGZus{}DEFAULT}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{constant}\PYG{+w}{ }\PYG{n}{C\PYGZus{}CLK\PYGZus{}PERIOD}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k+kt}{time}\PYG{+w}{ }\PYG{o}{:}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{;}

\PYG{k}{begin}

\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Instantiate test harness}
\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} i\PYGZus{}test\PYGZus{}harness : entity work.test\PYGZus{}harness;}


\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} PROCESS: p\PYGZus{}main}
\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{  }\PYG{n+nc}{p\PYGZus{}main}\PYG{o}{:}\PYG{+w}{ }\PYG{k}{process}

\PYG{+w}{  }\PYG{k}{begin}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Wait for UVVM to finish initialization}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} await\PYGZus{}uvvm\PYGZus{}initialization(VOID);}

\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Set UVVM verbosity level}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} enable\PYGZus{}log\PYGZus{}msg(ALL\PYGZus{}MESSAGES);}
\PYG{+w}{    }\PYG{n}{disable\PYGZus{}log\PYGZus{}msg}\PYG{p}{(}\PYG{n}{ALL\PYGZus{}MESSAGES}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{enable\PYGZus{}log\PYGZus{}msg}\PYG{p}{(}\PYG{n}{ID\PYGZus{}SEQUENCER}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{enable\PYGZus{}log\PYGZus{}msg}\PYG{p}{(}\PYG{n}{ID\PYGZus{}LOG\PYGZus{}HDR}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Test sequence}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{n}{log}\PYG{p}{(}\PYG{n}{ID\PYGZus{}SEQUENCER}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Running testcase: \PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{C\PYGZus{}SCOPE}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}check\PYGZus{}reset\PYGZus{}defaults\PYGZdq{}}\PYG{+w}{ }\PYG{k}{then}

\PYG{+w}{      }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} reset checks}

\PYG{+w}{    }\PYG{k}{elsif}\PYG{+w}{ }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}test\PYGZus{}dut\PYGZus{}write\PYGZdq{}}\PYG{+w}{ }\PYG{k}{then}

\PYG{+w}{      }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} write checks}

\PYG{+w}{    }\PYG{k}{elsif}\PYG{+w}{ }\PYG{n}{GC\PYGZus{}TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}test\PYGZus{}dut\PYGZus{}read\PYGZdq{}}\PYG{+w}{ }\PYG{k}{then}

\PYG{+w}{      }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} read checks}

\PYG{+w}{    }\PYG{k}{end}\PYG{+w}{ }\PYG{k}{if}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Ending the simulation}
\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{k}{wait}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }\PYG{l+m+mi}{1000}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{;}\PYG{+w}{             }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} to allow some time for completion}
\PYG{+w}{    }\PYG{n}{report\PYGZus{}alert\PYGZus{}counters}\PYG{p}{(}\PYG{n}{FINAL}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Report final counters and print conclusion for simulation (Success/Fail)}
\PYG{+w}{    }\PYG{n}{log}\PYG{p}{(}\PYG{n}{ID\PYGZus{}LOG\PYGZus{}HDR}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}SIMULATION COMPLETED\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{C\PYGZus{}SCOPE}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Finish the simulation}
\PYG{+w}{    }\PYG{n+nn}{std}\PYG{n+nn}{.env}\PYG{p}{.}\PYG{n}{stop}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{wait}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{\PYGZhy{}\PYGZhy{} to stop completely}
\PYG{+w}{  }\PYG{k}{end}\PYG{+w}{ }\PYG{k}{process}\PYG{+w}{ }\PYG{n+nc}{p\PYGZus{}main}\PYG{p}{;}

\PYG{k}{end}\PYG{+w}{ }\PYG{n+nc}{func}\PYG{p}{;}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{Verilog testbench example}
\def\sphinxLiteralBlockLabel{\label{\detokenize{testbench:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//hdlregression:tb}
\PYG{k}{module}\PYG{+w}{ }\PYG{n}{tb\PYGZus{}verilog}\PYG{+w}{ }\PYG{p}{\PYGZsh{}}\PYG{p}{(}
\PYG{+w}{        }\PYG{k}{parameter}\PYG{+w}{ }\PYG{n}{TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DEFAULT}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{initial}
\PYG{+w}{    }\PYG{k}{begin}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{reset\PYGZus{}test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{            }\PYG{c+c1}{// reset checks}

\PYG{+w}{        }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{write\PYGZus{}test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{            }\PYG{c+c1}{// write tests}

\PYG{+w}{        }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{TESTCASE}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{read\PYGZus{}test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{            }\PYG{c+c1}{// read tests}

\PYG{+w}{    }\PYG{k}{end}

\PYG{k}{endmodule}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Template files}
\label{\detokenize{templates:template-files}}\label{\detokenize{templates::doc}}

\section{Basic usage}
\label{\detokenize{templates:basic-usage}}
\sphinxAtStartPar
The HDLRegression package comes with a basic template file to ease the process of getting started for new users.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER HDLRegression PATH \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} If HDLRegression is not installed as a Python package (see doc)}
\PYG{c+c1}{\PYGZsh{} then uncomment the following line and set the path for}
\PYG{c+c1}{\PYGZsh{} the HDLRegression install folder :}
\PYG{c+c1}{\PYGZsh{}sys.path.append(\PYGZlt{}full\PYGZus{}or\PYGZus{}relative\PYGZus{}path\PYGZus{}to\PYGZus{}hdlregression\PYGZus{}install\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Import the HDLRegression module to the Python script:}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}

\PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
\PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{})                   \PYGZsh{} Use default library my\PYGZus{}work\PYGZus{}lib}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{}, \PYGZlt{}library\PYGZus{}name\PYGZgt{})   \PYGZsh{} or specify a library name.}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Basic example}
\label{\detokenize{templates:basic-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{c+c1}{\PYGZsh{} User specify HDLRegression install path:}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c:/tools/hdlregression/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Import the HDLRegression module to the Python script:}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}

\PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
\PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Add all .vhd files in the /src directory to library my\PYGZus{}dut\PYGZus{}lib:}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}dut\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add testbech file to library my\PYGZus{}tb\PYGZus{}lib:}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./tb/my\PYGZus{}tb.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}tb\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Advanced usage}
\label{\detokenize{templates:advanced-usage}}
\sphinxAtStartPar
The HDLRegression package comes with an advanced template file for advanced users to extend with even more
functionality.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER HDLRegression PATH \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} If HDLRegression is not installed as a Python package (see doc)}
\PYG{c+c1}{\PYGZsh{} then uncomment the following line and set the path for}
\PYG{c+c1}{\PYGZsh{} the HDLRegression install folder :}
\PYG{c+c1}{\PYGZsh{}sys.path.append(\PYGZlt{}full\PYGZus{}or\PYGZus{}relative\PYGZus{}path\PYGZus{}to\PYGZus{}hdlregression\PYGZus{}install\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Import the HDLRegression module to the Python script:}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER IMPORT \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Import other Python package(s):}

\PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
\PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Add Python functions here if needed:}

\PYG{c+c1}{\PYGZsh{} Add design files, repeat call if needed:}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}src\PYGZus{}files\PYGZgt{}, \PYGZlt{}compile\PYGZus{}library\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Add testbench and related files:}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}src\PYGZus{}files\PYGZgt{}, \PYGZlt{}compile\PYGZus{}library\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Define testbench configurations/generics if any, repeat call if needed:}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}generics(entity=\PYGZlt{}testbench\PYGZus{}name\PYGZgt{}, architecture=\PYGZlt{}architecture\PYGZus{}name\PYGZgt{}, generics=\PYGZlt{}generics\PYGZus{}list\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Define simulation report format:}
\PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.gen\PYGZus{}report() \PYGZsh{} default is full report (testbench, testcase, configurations, pass/fail) to report.txt}


\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Advanced example}
\label{\detokenize{templates:advanced-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{itertools} \PYG{k+kn}{import} \PYG{n}{product}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{c+c1}{\PYGZsh{} User specify HDLRegression install path:}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c:/tools/hdlregression/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Import the HDLRegression module to the Python script:}

\PYG{c+c1}{\PYGZsh{} Import other Python package(s):}


\PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
\PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Add Python functions here if needed:}

\PYG{c+c1}{\PYGZsh{} Return a list with the product of the generics}


\PYG{k}{def} \PYG{n+nf}{create\PYGZus{}generics}\PYG{p}{(}\PYG{n}{bus\PYGZus{}width}\PYG{p}{,} \PYG{n}{master\PYGZus{}mode}\PYG{p}{,} \PYG{n}{input\PYGZus{}file}\PYG{p}{,} \PYG{n}{output\PYGZus{}file}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{generics} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{bus\PYGZus{}width}\PYG{p}{,} \PYG{n}{master\PYGZus{}mode}\PYG{p}{,} \PYG{n}{input\PYGZus{}file}\PYG{p}{,} \PYG{n}{output\PYGZus{}file} \PYG{o+ow}{in} \PYG{n}{product}\PYG{p}{(}\PYG{n}{bus\PYGZus{}width}\PYG{p}{,} \PYG{n}{master\PYGZus{}mode}\PYG{p}{,} \PYG{n}{input\PYGZus{}file}\PYG{p}{,} \PYG{n}{output\PYGZus{}file}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{generics}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}BUS\PYGZus{}WIDTH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{bus\PYGZus{}width}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}MASTER\PYGZus{}MODE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{master\PYGZus{}mode}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}INPUT\PYGZus{}FILE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{input\PYGZus{}file}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GC\PYGZus{}OUTPUT\PYGZus{}FILE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{output\PYGZus{}file}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{generics}


\PYG{c+c1}{\PYGZsh{} Add all source files to library my\PYGZus{}dut\PYGZus{}lib:}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./src/*.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}dut\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Add all testbench related files to library my\PYGZus{}tb\PYGZus{}lib:}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{set\PYGZus{}library}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}tb\PYGZus{}lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./tb/my\PYGZus{}dut\PYGZus{}tb.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./tb/my\PYGZus{}dut\PYGZus{}th.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./tb/my\PYGZus{}dut\PYGZus{}if\PYGZus{}stuck\PYGZus{}tb.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./tb/my\PYGZus{}dut\PYGZus{}pin\PYGZus{}pulse\PYGZus{}tb.vhd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Get a list with the product of selected generics:}
\PYG{n}{generics} \PYG{o}{=} \PYG{n}{create\PYGZus{}generics}\PYG{p}{(}\PYG{n}{bus\PYGZus{}width}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{,} \PYG{n}{master\PYGZus{}mode}\PYG{o}{=}\PYG{p}{[}
                           \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{]}\PYG{p}{,} \PYG{n}{input\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{in\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{output\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{out\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add generics for testbench run:}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{add\PYGZus{}generics}\PYG{p}{(}\PYG{n}{entity}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}dut\PYGZus{}tb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{generics}\PYG{o}{=}\PYG{n}{generics}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Specify output report as CSV:}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{gen\PYGZus{}report}\PYG{p}{(}\PYG{n}{report\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{project\PYGZus{}report.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{n}{regression\PYGZus{}mode}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{RTL and Netlist script example}
\label{\detokenize{templates:rtl-and-netlist-script-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER HDLRegression PATH \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} If HDLRegression is not installed as a Python package (see doc)}
\PYG{c+c1}{\PYGZsh{} then uncomment the following line and set the path for}
\PYG{c+c1}{\PYGZsh{} the HDLRegression install folder :}
\PYG{c+c1}{\PYGZsh{}sys.path.append(\PYGZlt{}full\PYGZus{}or\PYGZus{}relative\PYGZus{}path\PYGZus{}to\PYGZus{}HDLRegression\PYGZus{}install\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Import the HDLRegression module to the Python script:}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}


\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}rtl}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Setup test environment for RTL simulations.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
    \PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{})                   \PYGZsh{} Use default library my\PYGZus{}work\PYGZus{}lib}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{}, \PYGZlt{}library\PYGZus{}name\PYGZgt{})   \PYGZsh{} or specify a library name.}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}



\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}netlist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Setup test environment for Netlist simulations.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
    \PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{})                   \PYGZsh{} Use default library my\PYGZus{}work\PYGZus{}lib}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{}, \PYGZlt{}library\PYGZus{}name\PYGZgt{})   \PYGZsh{} or specify a library name.}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Main method, selecting RTL or Netlist simulations.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}

    \PYG{n}{args} \PYG{o}{=} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}

    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{selection} \PYG{o}{=} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{selection}\PYG{p}{)}

        \PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rtl}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{==} \PYG{n}{selection}\PYG{p}{:}
            \PYG{n}{run\PYGZus{}rtl}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{elif} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{netlist}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{==} \PYG{n}{selection}\PYG{p}{:}
            \PYG{n}{run\PYGZus{}netlist}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please select }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{rtl}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ or }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{netlist}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ run.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please select }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{rtl}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ or }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{netlist}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ run.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Test Automation Server}
\label{\detokenize{ci:test-automation-server}}\label{\detokenize{ci::doc}}
\sphinxAtStartPar
HDLRegression support development automation server tools such as Jenkins and GitLab. When using HDLRegression with an automation
server the test runner script will need to utilize the statistical method \sphinxcode{\sphinxupquote{get\_num\_fail\_tests()}} in HDLRegression and
exit with an exit code to trigger a PASS/FAIL test in the automation server.

\sphinxAtStartPar
\sphinxstylestrong{Example code \sphinxhyphen{} returning the number of failing tests to the automation server:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} run tests}
\PYG{n}{ret\PYGZus{}code} \PYG{o}{=} \PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} exit with the return code from start()}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{ret\PYGZus{}code}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The automation server will indicate a passing test when the test runnner script returns ‘\sphinxstylestrong{0}’ exit code,
and \sphinxcode{\sphinxupquote{start()}} will return ‘\sphinxstylestrong{0}’ if all tests have passed and there are no compilation errors.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Example of building HDLRegression package and running test script in Jenkins:}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=750\sphinxpxdimen]{{jenkins_ci}.png}\hspace*{\fill}}

\sphinxstepscope


\chapter{Generated output}
\label{\detokenize{output:generated-output}}\label{\detokenize{output::doc}}
\sphinxAtStartPar
When a HDLRegression regression script is run a folder \sphinxtitleref{hdlregression} will be created in the same folder as the script was called
from, e.g. \sphinxtitleref{sim}. The folder will hold important project information in \sphinxtitleref{.dat} files, a list of all run commands inside
a \sphinxtitleref{commands.do} file, library compilations inside a \sphinxtitleref{library} folder, and test run outputs and report information inside
a \sphinxtitleref{test} folder. Note that each time the regression script is run it will back\sphinxhyphen{}up the \sphinxtitleref{test} folder with a date\sphinxhyphen{}and\sphinxhyphen{}time
suffix to ensure that no important test run results are overwritten.
\begin{itemize}
\item {} 
\sphinxAtStartPar
/library

\item {} 
\sphinxAtStartPar
/test

\item {} 
\sphinxAtStartPar
commands.do

\item {} 
\sphinxAtStartPar
library.dat

\item {} 
\sphinxAtStartPar
settings.dat

\item {} 
\sphinxAtStartPar
testgroup.dat

\item {} 
\sphinxAtStartPar
testgroup\_collection.dat

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The library folder will include one or more folders for the compiled libraries.
The test folder will include one or more testcase folders and \sphinxhyphen{} if selected \sphinxhyphen{} a coverage folder.
\end{sphinxadmonition}


\section{Test folder}
\label{\detokenize{output:test-folder}}
\sphinxAtStartPar
Inside thet \sphinxtitleref{/test} folder there can be several sub\sphinxhyphen{}folders and files. Each testbench entity will have a folder of its own
which again has sub\sphinxhyphen{}folders for used architecture and generics. These \sphinxtitleref{test run} folders have unique names that are
hash generated, thus identifying a specific test run can be done by inspecting the test mapping file, \sphinxtitleref{test\_mapping.csv}.
\sphinxSetupCaptionForVerbatim{HDLRegression output folder example}
\def\sphinxLiteralBlockLabel{\label{\detokenize{output:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+go}{hdlregression}
\PYG{g+go}{├── commands.do}
\PYG{g+go}{├── generic.dat}
\PYG{g+go}{├── library}
\PYG{g+go}{│   ├── bitvis\PYGZus{}uart}
\PYG{g+go}{│   │   ├── \PYGZus{}info}
\PYG{g+go}{│   │   ├── \PYGZus{}lib.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qpg}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qtl}
\PYG{g+go}{│   │   └── \PYGZus{}vmake}
\PYG{g+go}{│   ├── bitvis\PYGZus{}vip\PYGZus{}clock\PYGZus{}generator}
\PYG{g+go}{│   │   ├── \PYGZus{}info}
\PYG{g+go}{│   │   ├── \PYGZus{}lib.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qpg}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qtl}
\PYG{g+go}{│   │   └── \PYGZus{}vmake}
\PYG{g+go}{│   ├── bitvis\PYGZus{}vip\PYGZus{}sbi}
\PYG{g+go}{│   │   ├── \PYGZus{}info}
\PYG{g+go}{│   │   ├── \PYGZus{}lib.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qpg}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qtl}
\PYG{g+go}{│   │   └── \PYGZus{}vmake}
\PYG{g+go}{│   ├── bitvis\PYGZus{}vip\PYGZus{}scoreboard}
\PYG{g+go}{│   │   ├── \PYGZus{}info}
\PYG{g+go}{│   │   ├── \PYGZus{}lib.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qpg}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qtl}
\PYG{g+go}{│   │   └── \PYGZus{}vmake}
\PYG{g+go}{│   ├── bitvis\PYGZus{}vip\PYGZus{}uart}
\PYG{g+go}{│   │   ├── \PYGZus{}info}
\PYG{g+go}{│   │   ├── \PYGZus{}lib.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qpg}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qtl}
\PYG{g+go}{│   │   └── \PYGZus{}vmake}
\PYG{g+go}{│   ├── modelsim.ini}
\PYG{g+go}{│   ├── uvvm\PYGZus{}util}
\PYG{g+go}{│   │   ├── \PYGZus{}info}
\PYG{g+go}{│   │   ├── \PYGZus{}lib.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qdb}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qpg}
\PYG{g+go}{│   │   ├── \PYGZus{}lib1\PYGZus{}0.qtl}
\PYG{g+go}{│   │   └── \PYGZus{}vmake}
\PYG{g+go}{│   └── uvvm\PYGZus{}vvc\PYGZus{}framework}
\PYG{g+go}{│       ├── \PYGZus{}info}
\PYG{g+go}{│       ├── \PYGZus{}lib.qdb}
\PYG{g+go}{│       ├── \PYGZus{}lib1\PYGZus{}0.qdb}
\PYG{g+go}{│       ├── \PYGZus{}lib1\PYGZus{}0.qpg}
\PYG{g+go}{│       ├── \PYGZus{}lib1\PYGZus{}0.qtl}
\PYG{g+go}{│       └── \PYGZus{}vmake}
\PYG{g+go}{├── library.dat}
\PYG{g+go}{├── settings.dat}
\PYG{g+go}{├── test}
\PYG{g+go}{│   ├── irqc\PYGZus{}demo\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}1}
\PYG{g+go}{│   │       ├── \PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── \PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   ├── irqc\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}2}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   ├── sim\PYGZus{}report.json}
\PYG{g+go}{│   ├── test\PYGZus{}mapping.csv}
\PYG{g+go}{│   ├── uart\PYGZus{}simple\PYGZus{}bfm\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}4}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   ├── uart\PYGZus{}vvc\PYGZus{}demo\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}3}
\PYG{g+go}{│   │       ├── \PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── \PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   └── uart\PYGZus{}vvc\PYGZus{}tb}
\PYG{g+go}{│       ├── func\PYGZus{}10}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}Log.txt}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}11}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}with\PYGZus{}delay\PYGZus{}functionality\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}with\PYGZus{}delay\PYGZus{}functionality\PYGZus{}Log.txt}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}5}
\PYG{g+go}{│       │   ├── check\PYGZus{}register\PYGZus{}defaults\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}register\PYGZus{}defaults\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}6}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}transmit\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}transmit\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}7}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}receive\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}receive\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}8}
\PYG{g+go}{│       │   ├── check\PYGZus{}single\PYGZus{}simultaneous\PYGZus{}transmit\PYGZus{}and\PYGZus{}receive\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}single\PYGZus{}simultaneous\PYGZus{}transmit\PYGZus{}and\PYGZus{}receive\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       └── func\PYGZus{}9}
\PYG{g+go}{│           ├── check\PYGZus{}multiple\PYGZus{}simultaneous\PYGZus{}receive\PYGZus{}and\PYGZus{}read\PYGZus{}Alert.txt}
\PYG{g+go}{│           ├── check\PYGZus{}multiple\PYGZus{}simultaneous\PYGZus{}receive\PYGZus{}and\PYGZus{}read\PYGZus{}Log.txt}
\PYG{g+go}{│           ├── run.do}
\PYG{g+go}{│           └── transcript}
\PYG{g+go}{├── test\PYGZus{}2024\PYGZhy{}01\PYGZhy{}10\PYGZus{}14.51.25.645865}
\PYG{g+go}{│   ├── irqc\PYGZus{}demo\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}1}
\PYG{g+go}{│   │       ├── \PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── \PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   ├── irqc\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}2}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   ├── sim\PYGZus{}report.json}
\PYG{g+go}{│   ├── test\PYGZus{}mapping.csv}
\PYG{g+go}{│   ├── uart\PYGZus{}simple\PYGZus{}bfm\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}4}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── UVVM\PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   ├── uart\PYGZus{}vvc\PYGZus{}demo\PYGZus{}tb}
\PYG{g+go}{│   │   └── func\PYGZus{}3}
\PYG{g+go}{│   │       ├── \PYGZus{}Alert.txt}
\PYG{g+go}{│   │       ├── \PYGZus{}Log.txt}
\PYG{g+go}{│   │       ├── run.do}
\PYG{g+go}{│   │       └── transcript}
\PYG{g+go}{│   └── uart\PYGZus{}vvc\PYGZus{}tb}
\PYG{g+go}{│       ├── func\PYGZus{}10}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}Log.txt}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}11}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}with\PYGZus{}delay\PYGZus{}functionality\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}with\PYGZus{}delay\PYGZus{}functionality\PYGZus{}Log.txt}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}5}
\PYG{g+go}{│       │   ├── check\PYGZus{}register\PYGZus{}defaults\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}register\PYGZus{}defaults\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}6}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}transmit\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}transmit\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}7}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}receive\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}simple\PYGZus{}receive\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       ├── func\PYGZus{}8}
\PYG{g+go}{│       │   ├── check\PYGZus{}single\PYGZus{}simultaneous\PYGZus{}transmit\PYGZus{}and\PYGZus{}receive\PYGZus{}Alert.txt}
\PYG{g+go}{│       │   ├── check\PYGZus{}single\PYGZus{}simultaneous\PYGZus{}transmit\PYGZus{}and\PYGZus{}receive\PYGZus{}Log.txt}
\PYG{g+go}{│       │   ├── run.do}
\PYG{g+go}{│       │   └── transcript}
\PYG{g+go}{│       └── func\PYGZus{}9}
\PYG{g+go}{│           ├── check\PYGZus{}multiple\PYGZus{}simultaneous\PYGZus{}receive\PYGZus{}and\PYGZus{}read\PYGZus{}Alert.txt}
\PYG{g+go}{│           ├── check\PYGZus{}multiple\PYGZus{}simultaneous\PYGZus{}receive\PYGZus{}and\PYGZus{}read\PYGZus{}Log.txt}
\PYG{g+go}{│           ├── run.do}
\PYG{g+go}{│           └── transcript}
\PYG{g+go}{├── testcase.dat}
\PYG{g+go}{├── testgroup.dat}
\PYG{g+go}{└── testgroup\PYGZus{}collection.dat}
\end{sphinxVerbatim}


\subsection{Test mapping}
\label{\detokenize{output:test-mapping}}
\sphinxAtStartPar
A test mapping file \sphinxtitleref{test\_mapping.csv} is located in every \sphinxtitleref{test} folder to help identify test runs with test
output folders. An example of the layout of a test mapping file is shown below:
\sphinxSetupCaptionForVerbatim{test\_mapping.csv example}
\def\sphinxLiteralBlockLabel{\label{\detokenize{output:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{1, ./hdlregression/test/irqc\PYGZus{}demo\PYGZus{}tb/func\PYGZus{}1, bitvis\PYGZus{}irqc.irqc\PYGZus{}demo\PYGZus{}tb(func)}
\PYG{g+go}{2, ./hdlregression/test/irqc\PYGZus{}tb/func\PYGZus{}2, bitvis\PYGZus{}irqc.irqc\PYGZus{}tb(func)}
\PYG{g+go}{3, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}demo\PYGZus{}tb/func\PYGZus{}3, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}demo\PYGZus{}tb(func)}
\PYG{g+go}{4, ./hdlregression/test/uart\PYGZus{}simple\PYGZus{}bfm\PYGZus{}tb/func\PYGZus{}4, bitvis\PYGZus{}uart.uart\PYGZus{}simple\PYGZus{}bfm\PYGZus{}tb(func)}
\PYG{g+go}{5, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/func\PYGZus{}5, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}tb(func):GC\PYGZus{}TESTCASE=check\PYGZus{}register\PYGZus{}defaults}
\PYG{g+go}{6, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/func\PYGZus{}6, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}tb(func):GC\PYGZus{}TESTCASE=check\PYGZus{}simple\PYGZus{}transmit}
\PYG{g+go}{7, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/func\PYGZus{}7, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}tb(func):GC\PYGZus{}TESTCASE=check\PYGZus{}simple\PYGZus{}receive}
\PYG{g+go}{8, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/func\PYGZus{}8, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}tb(func):GC\PYGZus{}TESTCASE=check\PYGZus{}single\PYGZus{}simultaneous\PYGZus{}transmit\PYGZus{}and\PYGZus{}receive}
\PYG{g+go}{9, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/func\PYGZus{}9, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}tb(func):GC\PYGZus{}TESTCASE=check\PYGZus{}multiple\PYGZus{}simultaneous\PYGZus{}receive\PYGZus{}and\PYGZus{}read}
\PYG{g+go}{10, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/func\PYGZus{}10, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}tb(func):GC\PYGZus{}TESTCASE=skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive}
\PYG{g+go}{11, ./hdlregression/test/uart\PYGZus{}vvc\PYGZus{}tb/func\PYGZus{}11, bitvis\PYGZus{}uart.uart\PYGZus{}vvc\PYGZus{}tb(func):GC\PYGZus{}TESTCASE=skew\PYGZus{}sbi\PYGZus{}read\PYGZus{}over\PYGZus{}uart\PYGZus{}receive\PYGZus{}with\PYGZus{}delay\PYGZus{}functionality}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Tips}
\label{\detokenize{tips:tips}}\label{\detokenize{tips::doc}}

\section{Back annotated netlist simulations}
\label{\detokenize{tips:back-annotated-netlist-simulations}}
\sphinxAtStartPar
Running RTL and Netlist simulations require two individual test runs, i.e. different HDLRegression instances, and solving
this can be done using one or two regression scripts:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use two run scripts, e.g. \sphinxcode{\sphinxupquote{run\_rtl.py}} and \sphinxcode{\sphinxupquote{run\_netlist.py}}, and setup both scripts as individual runs,
one running RTL simulations and the other running Netlist simulations.

\item {} 
\sphinxAtStartPar
Combine both run scripts in a single file, e.g. \sphinxcode{\sphinxupquote{run\_regression.py}}, and use a selection mechanism inside the
run script to select which run to execute.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The single runner script example will support HDLRegression CLI arguments when implemented with
argument modifications as shown in the example below.
\end{sphinxadmonition}


\subsection{Regression script}
\label{\detokenize{tips:regression-script}}
\sphinxAtStartPar
\sphinxstylestrong{Example of running RTL and Netlist from two runner scripts}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python3} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{run\PYGZus{}rtl}\PYG{o}{.}\PYG{n}{py}

\PYG{n}{python3} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{run\PYGZus{}netlist}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example of running RTL and Netlist from a single runner script}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python3} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{run\PYGZus{}regression}\PYG{o}{.}\PYG{n}{py} \PYG{n}{rtl}

\PYG{n}{python3} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{run\PYGZus{}regression}\PYG{o}{.}\PYG{n}{py} \PYG{n}{netlist}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Example setup for running RTL and Netlist from a single runner script}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER HDLRegression PATH \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} If HDLRegression is not installed as a Python package (see doc)}
\PYG{c+c1}{\PYGZsh{} then uncomment the following line and set the path for}
\PYG{c+c1}{\PYGZsh{} the HDLRegression install folder :}
\PYG{c+c1}{\PYGZsh{}sys.path.append(\PYGZlt{}full\PYGZus{}or\PYGZus{}relative\PYGZus{}path\PYGZus{}to\PYGZus{}HDLRegression\PYGZus{}install\PYGZgt{})}

\PYG{c+c1}{\PYGZsh{} Import the HDLRegression module to the Python script:}
\PYG{k+kn}{from} \PYG{n+nn}{hdlregression} \PYG{k+kn}{import} \PYG{n}{HDLRegression}


\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}rtl}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Setup test environment for RTL simulations.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
    \PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{})                   \PYGZsh{} Use default library my\PYGZus{}work\PYGZus{}lib}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{}, \PYGZlt{}library\PYGZus{}name\PYGZgt{})   \PYGZsh{} or specify a library name.}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}



\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}netlist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Setup test environment for Netlist simulations.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} Define a HDLRegression item to access the HDLRegression functionality:}
    \PYG{n}{hr} \PYG{o}{=} \PYG{n}{HDLRegression}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG START \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{})                   \PYGZsh{} Use default library my\PYGZus{}work\PYGZus{}lib}
    \PYG{c+c1}{\PYGZsh{} =\PYGZgt{} hr.add\PYGZus{}files(\PYGZlt{}filename\PYGZgt{}, \PYGZlt{}library\PYGZus{}name\PYGZgt{})   \PYGZsh{} or specify a library name.}

    \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} USER CONFIG END \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
    \PYG{n}{hr}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Main method, selecting RTL or Netlist simulations.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}

    \PYG{n}{args} \PYG{o}{=} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}

    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{selection} \PYG{o}{=} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{selection}\PYG{p}{)}

        \PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rtl}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{==} \PYG{n}{selection}\PYG{p}{:}
            \PYG{n}{run\PYGZus{}rtl}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{elif} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{netlist}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{==} \PYG{n}{selection}\PYG{p}{:}
            \PYG{n}{run\PYGZus{}netlist}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please select }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{rtl}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ or }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{netlist}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ run.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please select }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{rtl}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ or }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{netlist}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ run.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=550\sphinxpxdimen]{{hdlregression_scaled}.png}\hspace*{\fill}}



\renewcommand{\indexname}{Index}
\printindex
\end{document}